<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Thu May  9 06:35:01 2024 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title>XZ</title>

</head>
<body>

<h1 align="center">XZ</h1>

<a href="#NAME">NAME</a><br>
<a href="#SYNOPSIS">SYNOPSIS</a><br>
<a href="#COMMAND ALIASES">COMMAND ALIASES</a><br>
<a href="#DESCRIPTION">DESCRIPTION</a><br>
<a href="#OPTIONS">OPTIONS</a><br>
<a href="#ROBOT MODE">ROBOT MODE</a><br>
<a href="#EXIT STATUS">EXIT STATUS</a><br>
<a href="#ENVIRONMENT">ENVIRONMENT</a><br>
<a href="#LZMA UTILS COMPATIBILITY">LZMA UTILS COMPATIBILITY</a><br>
<a href="#NOTES">NOTES</a><br>
<a href="#EXAMPLES">EXAMPLES</a><br>
<a href="#SEE ALSO">SEE ALSO</a><br>

<hr>


<h2>NAME
<a name="NAME"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">xz, unxz,
xzcat, lzma, unlzma, lzcat - Compress or decompress .xz and
.lzma files</p>

<h2>SYNOPSIS
<a name="SYNOPSIS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>xz</b>
[<i>option...</i>] [<i>file...</i>]</p>

<h2>COMMAND ALIASES
<a name="COMMAND ALIASES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>unxz</b> is
equivalent to <b>xz --decompress</b>. <b><br>
xzcat</b> is equivalent to <b>xz --decompress --stdout</b>.
<b><br>
lzma</b> is equivalent to <b>xz --format=lzma</b>. <b><br>
unlzma</b> is equivalent to <b>xz --format=lzma
--decompress</b>. <b><br>
lzcat</b> is equivalent to <b>xz --format=lzma --decompress
--stdout</b>.</p>

<p style="margin-left:11%; margin-top: 1em">When writing
scripts that need to decompress files, it is recommended to
always use the name <b>xz</b> with appropriate arguments
(<b>xz -d</b> or <b>xz -dc</b>) instead of the names
<b>unxz</b> and <b>xzcat</b>.</p>

<h2>DESCRIPTION
<a name="DESCRIPTION"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>xz</b> is a
general-purpose data compression tool with command line
syntax similar to <b>gzip</b>(1) and <b>bzip2</b>(1). The
native file format is the <b>.xz</b> format, but the legacy
<b>.lzma</b> format used by LZMA Utils and raw compressed
streams with no container format headers are also supported.
In addition, decompression of the <b>.lz</b> format used by
<b>lzip</b> is supported.</p>

<p style="margin-left:11%; margin-top: 1em"><b>xz</b>
compresses or decompresses each <i>file</i> according to the
selected operation mode. If no <i>files</i> are given or
<i>file</i> is <b>-</b>, <b>xz</b> reads from standard input
and writes the processed data to standard output. <b>xz</b>
will refuse (display an error and skip the <i>file</i>) to
write compressed data to standard output if it is a
terminal. Similarly, <b>xz</b> will refuse to read
compressed data from standard input if it is a terminal.</p>

<p style="margin-left:11%; margin-top: 1em">Unless
<b>--stdout</b> is specified, <i>files</i> other than
<b>-</b> are written to a new file whose name is derived
from the source <i>file</i> name:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="85%">


<p>When compressing, the suffix of the target file format
(<b>.xz</b> or <b>.lzma</b>) is appended to the source
filename to get the target filename.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="85%">


<p>When decompressing, the <b>.xz</b>, <b>.lzma</b>, or
<b>.lz</b> suffix is removed from the filename to get the
target filename. <b>xz</b> also recognizes the suffixes
<b>.txz</b> and <b>.tlz</b>, and replaces them with the
<b>.tar</b> suffix.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">If the target
file already exists, an error is displayed and the
<i>file</i> is skipped.</p>

<p style="margin-left:11%; margin-top: 1em">Unless writing
to standard output, <b>xz</b> will display a warning and
skip the <i>file</i> if any of the following applies:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em">&bull;</p></td>
<td width="3%"></td>
<td width="85%">


<p style="margin-top: 1em"><i>File</i> is not a regular
file. Symbolic links are not followed, and thus they are not
considered to be regular files.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="85%">


<p><i>File</i> has more than one hard link.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="85%">


<p><i>File</i> has setuid, setgid, or sticky bit set.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="85%">


<p>The operation mode is set to compress and the
<i>file</i> already has a suffix of the target file format
(<b>.xz</b> or <b>.txz</b> when compressing to the
<b>.xz</b> format, and <b>.lzma</b> or <b>.tlz</b> when
compressing to the <b>.lzma</b> format).</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="85%">


<p>The operation mode is set to decompress and the
<i>file</i> doesn&rsquo;t have a suffix of any of the
supported file formats (<b>.xz</b>, <b>.txz</b>,
<b>.lzma</b>, <b>.tlz</b>, or <b>.lz</b>).</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">After
successfully compressing or decompressing the <i>file</i>,
<b>xz</b> copies the owner, group, permissions, access time,
and modification time from the source <i>file</i> to the
target file. If copying the group fails, the permissions are
modified so that the target file doesn&rsquo;t become
accessible to users who didn&rsquo;t have permission to
access the source <i>file</i>. <b>xz</b> doesn&rsquo;t
support copying other metadata like access control lists or
extended attributes yet.</p>

<p style="margin-left:11%; margin-top: 1em">Once the target
file has been successfully closed, the source <i>file</i> is
removed unless <b>--keep</b> was specified. The source
<i>file</i> is never removed if the output is written to
standard output or if an error occurs.</p>

<p style="margin-left:11%; margin-top: 1em">Sending
<b>SIGINFO</b> or <b>SIGUSR1</b> to the <b>xz</b> process
makes it print progress information to standard error. This
has only limited use since when standard error is a
terminal, using <b>--verbose</b> will display an
automatically updating progress indicator.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Memory
usage</b> <br>
The memory usage of <b>xz</b> varies from a few hundred
kilobytes to several gigabytes depending on the compression
settings. The settings used when compressing a file
determine the memory requirements of the decompressor.
Typically the decompressor needs 5&nbsp;% to 20&nbsp;% of
the amount of memory that the compressor needed when
creating the file. For example, decompressing a file created
with <b>xz -9</b> currently requires 65&nbsp;MiB of memory.
Still, it is possible to have <b>.xz</b> files that require
several gigabytes of memory to decompress.</p>

<p style="margin-left:11%; margin-top: 1em">Especially
users of older systems may find the possibility of very
large memory usage annoying. To prevent uncomfortable
surprises, <b>xz</b> has a built-in memory usage limiter,
which is disabled by default. While some operating systems
provide ways to limit the memory usage of processes, relying
on it wasn&rsquo;t deemed to be flexible enough (for
example, using <b>ulimit</b>(1) to limit virtual memory
tends to cripple <b>mmap</b>(2)).</p>

<p style="margin-left:11%; margin-top: 1em">The memory
usage limiter can be enabled with the command line option
<b>--memlimit=</b><i>limit</i>. Often it is more convenient
to enable the limiter by default by setting the environment
variable <b>XZ_DEFAULTS</b>, for example,
<b>XZ_DEFAULTS=--memlimit=150MiB</b>. It is possible to set
the limits separately for compression and decompression by
using <b>--memlimit-compress=</b><i>limit</i> and
<b>--memlimit-decompress=</b><i>limit</i>. Using these two
options outside <b>XZ_DEFAULTS</b> is rarely useful because
a single run of <b>xz</b> cannot do both compression and
decompression and <b>--memlimit=</b><i>limit</i> (or
<b>-M</b> <i>limit</i>) is shorter to type on the command
line.</p>

<p style="margin-left:11%; margin-top: 1em">If the
specified memory usage limit is exceeded when decompressing,
<b>xz</b> will display an error and decompressing the file
will fail. If the limit is exceeded when compressing,
<b>xz</b> will try to scale the settings down so that the
limit is no longer exceeded (except when using
<b>--format=raw</b> or <b>--no-adjust</b>). This way the
operation won&rsquo;t fail unless the limit is very small.
The scaling of the settings is done in steps that
don&rsquo;t match the compression level presets, for
example, if the limit is only slightly less than the amount
required for <b>xz -9</b>, the settings will be scaled down
only a little, not all the way down to <b>xz -8</b>.</p>


<p style="margin-left:11%; margin-top: 1em"><b>Concatenation
and padding with .xz files</b> <br>
It is possible to concatenate <b>.xz</b> files as is.
<b>xz</b> will decompress such files as if they were a
single <b>.xz</b> file.</p>

<p style="margin-left:11%; margin-top: 1em">It is possible
to insert padding between the concatenated parts or after
the last part. The padding must consist of null bytes and
the size of the padding must be a multiple of four bytes.
This can be useful, for example, if the <b>.xz</b> file is
stored on a medium that measures file sizes in 512-byte
blocks.</p>

<p style="margin-left:11%; margin-top: 1em">Concatenation
and padding are not allowed with <b>.lzma</b> files or raw
streams.</p>

<h2>OPTIONS
<a name="OPTIONS"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Integer
suffixes and special values</b> <br>
In most places where an integer argument is expected, an
optional suffix is supported to easily indicate large
integers. There must be no space between the integer and the
suffix.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p style="margin-top: 1em"><b>KiB</b></p></td>
<td width="7%"></td>
<td width="78%">


<p style="margin-top: 1em">Multiply the integer by 1,024
(2^10). <b>Ki</b>, <b>k</b>, <b>kB</b>, <b>K</b>, and
<b>KB</b> are accepted as synonyms for <b>KiB</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>MiB</b></p></td>
<td width="7%"></td>
<td width="78%">


<p>Multiply the integer by 1,048,576 (2^20). <b>Mi</b>,
<b>m</b>, <b>M</b>, and <b>MB</b> are accepted as synonyms
for <b>MiB</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><b>GiB</b></p></td>
<td width="7%"></td>
<td width="78%">


<p>Multiply the integer by 1,073,741,824 (2^30). <b>Gi</b>,
<b>g</b>, <b>G</b>, and <b>GB</b> are accepted as synonyms
for <b>GiB</b>.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The special
value <b>max</b> can be used to indicate the maximum integer
value supported by the option.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Operation
mode</b> <br>
If multiple operation mode options are given, the last one
takes effect. <b><br>
-z</b>, <b>--compress</b></p>

<p style="margin-left:22%;">Compress. This is the default
operation mode when no operation mode option is specified
and no other operation mode is implied from the command name
(for example, <b>unxz</b> implies <b>--decompress</b>).</p>

<p style="margin-left:11%;"><b>-d</b>, <b>--decompress</b>,
<b>--uncompress</b></p>

<p style="margin-left:22%;">Decompress.</p>

<p style="margin-left:11%;"><b>-t</b>, <b>--test</b></p>

<p style="margin-left:22%;">Test the integrity of
compressed <i>files</i>. This option is equivalent to
<b>--decompress --stdout</b> except that the decompressed
data is discarded instead of being written to standard
output. No files are created or removed.</p>

<p style="margin-left:11%;"><b>-l</b>, <b>--list</b></p>

<p style="margin-left:22%;">Print information about
compressed <i>files</i>. No uncompressed output is produced,
and no files are created or removed. In list mode, the
program cannot read the compressed data from standard input
or from other unseekable sources.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p>The default listing shows basic information about
<i>files</i>, one file per line. To get more detailed
information, use also the <b>--verbose</b> option. For even
more information, use <b>--verbose</b> twice, but note that
this may be slow, because getting all the extra information
requires many seeks. The width of verbose output exceeds 80
characters, so piping the output to, for example,
<b>less&nbsp;-S</b> may be convenient if the terminal
isn&rsquo;t wide enough.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p>The exact output may vary between <b>xz</b> versions and
different locales. For machine-readable output, <b>--robot
--list</b> should be used.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Operation
modifiers <br>
-k</b>, <b>--keep</b></p>

<p style="margin-left:22%;">Don&rsquo;t delete the input
files.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p>Since <b>xz</b> 5.2.6, this option also makes <b>xz</b>
compress or decompress even if the input is a symbolic link
to a regular file, has more than one hard link, or has the
setuid, setgid, or sticky bit set. The setuid, setgid, and
sticky bits are not copied to the target file. In earlier
versions this was only done with <b>--force</b>.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>-f</b>, <b>--force</b></p>

<p style="margin-left:22%;">This option has several
effects:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="74%">


<p>If the target file already exists, delete it before
compressing or decompressing.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="74%">


<p>Compress or decompress even if the input is a symbolic
link to a regular file, has more than one hard link, or has
the setuid, setgid, or sticky bit set. The setuid, setgid,
and sticky bits are not copied to the target file.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="74%">


<p>When used with <b>--decompress --stdout</b> and
<b>xz</b> cannot recognize the type of the source file, copy
the source file as is to standard output. This allows
<b>xzcat --force</b> to be used like <b>cat</b>(1) for files
that have not been compressed with <b>xz</b>. Note that in
future, <b>xz</b> might support new compressed file formats,
which may make <b>xz</b> decompress more types of files
instead of copying them as is to standard output.
<b>--format=</b><i>format</i> can be used to restrict
<b>xz</b> to decompress only a single file format.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>-c</b>, <b>--stdout</b>,
<b>--to-stdout</b></p>

<p style="margin-left:22%;">Write the compressed or
decompressed data to standard output instead of a file. This
implies <b>--keep</b>.</p>

<p style="margin-left:11%;"><b>--single-stream</b></p>

<p style="margin-left:22%;">Decompress only the first
<b>.xz</b> stream, and silently ignore possible remaining
input data following the stream. Normally such trailing
garbage makes <b>xz</b> display an error.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p><b>xz</b> never decompresses more than one stream from
<b>.lzma</b> files or raw streams, but this option still
makes <b>xz</b> ignore the possible trailing data after the
<b>.lzma</b> file or raw stream.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p>This option has no effect if the operation mode is not
<b>--decompress</b> or <b>--test</b>.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>--no-sparse</b></p>

<p style="margin-left:22%;">Disable creation of sparse
files. By default, if decompressing into a regular file,
<b>xz</b> tries to make the file sparse if the decompressed
data contains long sequences of binary zeros. It also works
when writing to standard output as long as standard output
is connected to a regular file and certain additional
conditions are met to make it safe. Creating sparse files
may save disk space and speed up the decompression by
reducing the amount of disk I/O.</p>

<p style="margin-left:11%;"><b>-S</b> <i>.suf</i>,
<b>--suffix=</b><i>.suf</i></p>

<p style="margin-left:22%;">When compressing, use
<i>.suf</i> as the suffix for the target file instead of
<b>.xz</b> or <b>.lzma</b>. If not writing to standard
output and the source file already has the suffix
<i>.suf</i>, a warning is displayed and the file is
skipped.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p>When decompressing, recognize files with the suffix
<i>.suf</i> in addition to files with the <b>.xz</b>,
<b>.txz</b>, <b>.lzma</b>, <b>.tlz</b>, or <b>.lz</b>
suffix. If the source file has the suffix <i>.suf</i>, the
suffix is removed to get the target filename.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p>When compressing or decompressing raw streams
(<b>--format=raw</b>), the suffix must always be specified
unless writing to standard output, because there is no
default suffix for raw streams.</p></td></tr>
</table>


<p style="margin-left:11%;"><b>--files</b>[<b>=</b><i>file</i>]</p>

<p style="margin-left:22%;">Read the filenames to process
from <i>file</i>; if <i>file</i> is omitted, filenames are
read from standard input. Filenames must be terminated with
the newline character. A dash (<b>-</b>) is taken as a
regular filename; it doesn&rsquo;t mean standard input. If
filenames are given also as command line arguments, they are
processed before the filenames read from <i>file</i>.</p>


<p style="margin-left:11%;"><b>--files0</b>[<b>=</b><i>file</i>]</p>

<p style="margin-left:22%;">This is identical to
<b>--files</b>[<b>=</b><i>file</i>] except that each
filename must be terminated with the null character.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Basic file
format and compression options <br>
-F</b> <i>format</i>, <b>--format=</b><i>format</i></p>

<p style="margin-left:22%;">Specify the file <i>format</i>
to compress or decompress:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="6%">


<p><b>auto</b></p></td>
<td width="4%"></td>
<td width="68%">


<p>This is the default. When compressing, <b>auto</b> is
equivalent to <b>xz</b>. When decompressing, the format of
the input file is automatically detected. Note that raw
streams (created with <b>--format=raw</b>) cannot be
auto-detected.</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="6%">


<p><b>xz</b></p></td>
<td width="4%"></td>
<td width="68%">


<p>Compress to the <b>.xz</b> file format, or accept only
<b>.xz</b> files when decompressing.</p></td></tr>
</table>

<p style="margin-left:22%;"><b>lzma</b>, <b>alone</b></p>

<p style="margin-left:32%;">Compress to the legacy
<b>.lzma</b> file format, or accept only <b>.lzma</b> files
when decompressing. The alternative name <b>alone</b> is
provided for backwards compatibility with LZMA Utils.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="6%">


<p><b>lzip</b></p></td>
<td width="4%"></td>
<td width="68%">


<p>Accept only <b>.lz</b> files when decompressing.
Compression is not supported.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="6%">
</td>
<td width="4%"></td>
<td width="68%">


<p>The <b>.lz</b> format version 0 and the unextended
version 1 are supported. Version 0 files were produced by
<b>lzip</b> 1.3 and older. Such files aren&rsquo;t common
but may be found from file archives as a few source packages
were released in this format. People might have old personal
files in this format too. Decompression support for the
format version 0 was removed in <b>lzip</b> 1.18.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="6%">
</td>
<td width="4%"></td>
<td width="68%">


<p><b>lzip</b> 1.4 and later create files in the format
version 1. The sync flush marker extension to the format
version 1 was added in <b>lzip</b> 1.6. This extension is
rarely used and isn&rsquo;t supported by <b>xz</b>
(diagnosed as corrupt input).</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="6%">


<p><b>raw</b></p></td>
<td width="4%"></td>
<td width="68%">


<p>Compress or uncompress a raw stream (no headers). This
is meant for advanced users only. To decode raw streams, you
need use <b>--format=raw</b> and explicitly specify the
filter chain, which normally would have been stored in the
container headers.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>-C</b> <i>check</i>,
<b>--check=</b><i>check</i></p>

<p style="margin-left:22%;">Specify the type of the
integrity check. The check is calculated from the
uncompressed data and stored in the <b>.xz</b> file. This
option has an effect only when compressing into the
<b>.xz</b> format; the <b>.lzma</b> format doesn&rsquo;t
support integrity checks. The integrity check (if any) is
verified when the <b>.xz</b> file is decompressed.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="33%">


<p>Supported <i>check</i> types:</p></td>
<td width="45%">
</td></tr>
</table>

<p style="margin-left:22%;"><b>none</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="9%"></td>
<td width="1%"></td>
<td width="68%">


<p style="margin-top: 1em">Don&rsquo;t calculate an
integrity check at all. This is usually a bad idea. This can
be useful when integrity of the data is verified by other
means anyway.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="9%">


<p><b>crc32</b></p></td>
<td width="1%"></td>
<td width="68%">


<p>Calculate CRC32 using the polynomial from IEEE-802.3
(Ethernet).</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="9%">


<p><b>crc64</b></p></td>
<td width="1%"></td>
<td width="68%">


<p>Calculate CRC64 using the polynomial from ECMA-182. This
is the default, since it is slightly better than CRC32 at
detecting damaged files and the speed difference is
negligible.</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="9%">


<p><b>sha256</b></p></td>
<td width="1%"></td>
<td width="68%">


<p>Calculate SHA-256. This is somewhat slower than CRC32
and CRC64.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Integrity of
the <b>.xz</b> headers is always verified with CRC32. It is
not possible to change or disable it.</p>

<p style="margin-left:11%;"><b>--ignore-check</b></p>

<p style="margin-left:22%;">Don&rsquo;t verify the
integrity check of the compressed data when decompressing.
The CRC32 values in the <b>.xz</b> headers will still be
verified normally.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p><b>Do not use this option unless you know what you are
doing.</b> Possible reasons to use this option:</p></td></tr>
</table>

<p style="margin-left:22%;">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%"></td>
<td width="3%"></td>
<td width="74%">


<p style="margin-top: 1em">Trying to recover data from a
corrupt .xz file.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="74%">


<p>Speeding up decompression. This matters mostly with
SHA-256 or with files that have compressed extremely well.
It&rsquo;s recommended to not use this option for this
purpose unless the file integrity is verified externally in
some other way.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>-0</b> ... <b>-9</b></p>

<p style="margin-left:22%;">Select a compression preset
level. The default is <b>-6</b>. If multiple preset levels
are specified, the last one takes effect. If a custom filter
chain was already specified, setting a compression preset
level clears the custom filter chain.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p>The differences between the presets are more significant
than with <b>gzip</b>(1) and <b>bzip2</b>(1). The selected
compression settings determine the memory requirements of
the decompressor, thus using a too high preset level might
make it painful to decompress the file on an old system with
little RAM. Specifically, <b>it&rsquo;s not a good idea to
blindly use -9 for everything</b> like it often is with
<b>gzip</b>(1) and <b>bzip2</b>(1).</p></td></tr>
</table>

<p style="margin-left:22%;"><b>-0</b> ... <b>-3</b></p>

<p style="margin-left:32%;">These are somewhat fast
presets. <b>-0</b> is sometimes faster than <b>gzip -9</b>
while compressing much better. The higher ones often have
speed comparable to <b>bzip2</b>(1) with comparable or
better compression ratio, although the results depend a lot
on the type of data being compressed.</p>

<p style="margin-left:22%;"><b>-4</b> ... <b>-6</b></p>

<p style="margin-left:32%;">Good to very good compression
while keeping decompressor memory usage reasonable even for
old systems. <b>-6</b> is the default, which is usually a
good choice for distributing files that need to be
decompressible even on systems with only 16&nbsp;MiB RAM.
(<b>-5e</b> or <b>-6e</b> may be worth considering too. See
<b>--extreme</b>.)</p>

<p style="margin-left:22%;"><b>-7 ... -9</b></p>

<p style="margin-left:32%;">These are like <b>-6</b> but
with higher compressor and decompressor memory requirements.
These are useful only when compressing files bigger than
8&nbsp;MiB, 16&nbsp;MiB, and 32&nbsp;MiB, respectively.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p>On the same hardware, the decompression speed is
approximately a constant number of bytes of compressed data
per second. In other words, the better the compression, the
faster the decompression will usually be. This also means
that the amount of uncompressed output produced per second
can vary a lot.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p>The following table summarises the features of the
presets:</p> </td></tr>
</table>


<p align="center" style="margin-top: 1em"><img src="grohtml-207321.png" alt="Image grohtml-207321.png"></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="30%">


<p style="margin-top: 1em">Column descriptions:</p></td>
<td width="48%">
</td></tr>
</table>

<p style="margin-left:22%;">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%"></td>
<td width="3%"></td>
<td width="74%">


<p style="margin-top: 1em">DictSize is the LZMA2 dictionary
size. It is waste of memory to use a dictionary bigger than
the size of the uncompressed file. This is why it is good to
avoid using the presets <b>-7</b> ... <b>-9</b> when
there&rsquo;s no real need for them. At <b>-6</b> and lower,
the amount of memory wasted is usually low enough to not
matter.</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="74%">


<p>CompCPU is a simplified representation of the LZMA2
settings that affect compression speed. The dictionary size
affects speed too, so while CompCPU is the same for levels
<b>-6</b> ... <b>-9</b>, higher levels still tend to be a
little slower. To get even slower and thus possibly better
compression, see <b>--extreme</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="74%">


<p>CompMem contains the compressor memory requirements in
the single-threaded mode. It may vary slightly between
<b>xz</b> versions. Memory requirements of some of the
future multithreaded modes may be dramatically higher than
that of the single-threaded mode.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="74%">


<p>DecMem contains the decompressor memory requirements.
That is, the compression settings determine the memory
requirements of the decompressor. The exact decompressor
memory usage is slightly more than the LZMA2 dictionary
size, but the values in the table have been rounded up to
the next full MiB.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>-e</b>, <b>--extreme</b></p>

<p style="margin-left:22%;">Use a slower variant of the
selected compression preset level (<b>-0</b> ... <b>-9</b>)
to hopefully get a little bit better compression ratio, but
with bad luck this can also make it worse. Decompressor
memory usage is not affected, but compressor memory usage
increases a little at preset levels <b>-0</b> ...
<b>-3</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p>Since there are two presets with dictionary sizes
4&nbsp;MiB and 8&nbsp;MiB, the presets <b>-3e</b> and
<b>-5e</b> use slightly faster settings (lower CompCPU) than
<b>-4e</b> and <b>-6e</b>, respectively. That way no two
presets are identical.</p></td></tr>
</table>


<p align="center" style="margin-top: 1em"><img src="grohtml-207322.png" alt="Image grohtml-207322.png"></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">
</td>
<td width="2%"></td>
<td width="78%">


<p style="margin-top: 1em">For example, there are a total
of four presets that use 8&nbsp;MiB dictionary, whose order
from the fastest to the slowest is <b>-5</b>, <b>-6</b>,
<b>-5e</b>, and <b>-6e</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>--fast</b></p></td>
<td width="2%"></td>
<td width="78%">
</td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>--best</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>These are somewhat misleading aliases for <b>-0</b> and
<b>-9</b>, respectively. These are provided only for
backwards compatibility with LZMA Utils. Avoid using these
options.</p> </td></tr>
</table>


<p style="margin-left:11%;"><b>--block-size=</b><i>size</i></p>

<p style="margin-left:22%;">When compressing to the
<b>.xz</b> format, split the input data into blocks of
<i>size</i> bytes. The blocks are compressed independently
from each other, which helps with multi-threading and makes
limited random-access decompression possible. This option is
typically used to override the default block size in
multi-threaded mode, but this option can be used in
single-threaded mode too.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p>In multi-threaded mode about three times <i>size</i>
bytes will be allocated in each thread for buffering input
and output. The default <i>size</i> is three times the LZMA2
dictionary size or 1 MiB, whichever is more. Typically a
good value is 2&ndash;4 times the size of the LZMA2
dictionary or at least 1 MiB. Using <i>size</i> less than
the LZMA2 dictionary size is waste of RAM because then the
LZMA2 dictionary buffer will never get fully used. The sizes
of the blocks are stored in the block headers, which a
future version of <b>xz</b> will use for multi-threaded
decompression.</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p>In single-threaded mode no block splitting is done by
default. Setting this option doesn&rsquo;t affect memory
usage. No size information is stored in block headers, thus
files created in single-threaded mode won&rsquo;t be
identical to files created in multi-threaded mode. The lack
of size information also means that a future version of
<b>xz</b> won&rsquo;t be able decompress the files in
multi-threaded mode.</p></td></tr>
</table>


<p style="margin-left:11%;"><b>--block-list=</b><i>sizes</i></p>

<p style="margin-left:22%;">When compressing to the
<b>.xz</b> format, start a new block after the given
intervals of uncompressed data.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p>The uncompressed <i>sizes</i> of the blocks are
specified as a comma-separated list. Omitting a size (two or
more consecutive commas) is a shorthand to use the size of
the previous block.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p>If the input file is bigger than the sum of
<i>sizes</i>, the last value in <i>sizes</i> is repeated
until the end of the file. A special value of <b>0</b> may
be used as the last value to indicate that the rest of the
file should be encoded as a single block.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p>If one specifies <i>sizes</i> that exceed the
encoder&rsquo;s block size (either the default value in
threaded mode or the value specified with
<b>--block-size=</b><i>size</i>), the encoder will create
additional blocks while keeping the boundaries specified in
<i>sizes</i>. For example, if one specifies
<b>--block-size=10MiB
--block-list=5MiB,10MiB,8MiB,12MiB,24MiB</b> and the input
file is 80 MiB, one will get 11 blocks: 5, 10, 8, 10, 2, 10,
10, 4, 10, 10, and 1 MiB.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p>In multi-threaded mode the sizes of the blocks are
stored in the block headers. This isn&rsquo;t done in
single-threaded mode, so the encoded output won&rsquo;t be
identical to that of the multi-threaded mode.</p></td></tr>
</table>


<p style="margin-left:11%;"><b>--flush-timeout=</b><i>timeout</i></p>

<p style="margin-left:22%;">When compressing, if more than
<i>timeout</i> milliseconds (a positive integer) has passed
since the previous flush and reading more input would block,
all the pending input data is flushed from the encoder and
made available in the output stream. This can be useful if
<b>xz</b> is used to compress data that is streamed over a
network. Small <i>timeout</i> values make the data available
at the receiving end with a small delay, but large
<i>timeout</i> values give better compression ratio.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p>This feature is disabled by default. If this option is
specified more than once, the last one takes effect. The
special <i>timeout</i> value of <b>0</b> can be used to
explicitly disable this feature.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p>This feature is not available on non-POSIX systems.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p><b>This feature is still experimental.</b> Currently
<b>xz</b> is unsuitable for decompressing the stream in real
time due to how <b>xz</b> does buffering.</p></td></tr>
</table>


<p style="margin-left:11%;"><b>--memlimit-compress=</b><i>limit</i></p>

<p style="margin-left:22%;">Set a memory usage limit for
compression. If this option is specified multiple times, the
last one takes effect.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p>If the compression settings exceed the <i>limit</i>,
<b>xz</b> will attempt to adjust the settings downwards so
that the limit is no longer exceeded and display a notice
that automatic adjustment was done. The adjustments are done
in this order: reducing the number of threads, switching to
single-threaded mode if even one thread in multi-threaded
mode exceeds the <i>limit</i>, and finally reducing the
LZMA2 dictionary size.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p>When compressing with <b>--format=raw</b> or if
<b>--no-adjust</b> has been specified, only the number of
threads may be reduced since it can be done without
affecting the compressed output.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p>If the <i>limit</i> cannot be met even with the
adjustments described above, an error is displayed and
<b>xz</b> will exit with exit status 1.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p>The <i>limit</i> can be specified in multiple ways:</p></td></tr>
</table>

<p style="margin-left:22%;">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%"></td>
<td width="3%"></td>
<td width="74%">


<p style="margin-top: 1em">The <i>limit</i> can be an
absolute value in bytes. Using an integer suffix like
<b>MiB</b> can be useful. Example:
<b>--memlimit-compress=80MiB</b></p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="74%">


<p>The <i>limit</i> can be specified as a percentage of
total physical memory (RAM). This can be useful especially
when setting the <b>XZ_DEFAULTS</b> environment variable in
a shell initialization script that is shared between
different computers. That way the limit is automatically
bigger on systems with more memory. Example:
<b>--memlimit-compress=70%</b></p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="74%">


<p>The <i>limit</i> can be reset back to its default value
by setting it to <b>0</b>. This is currently equivalent to
setting the <i>limit</i> to <b>max</b> (no memory usage
limit).</p> </td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">For 32-bit
<b>xz</b> there is a special case: if the <i>limit</i> would
be over <b>4020&nbsp;MiB</b>, the <i>limit</i> is set to
<b>4020&nbsp;MiB</b>. On MIPS32 <b>2000&nbsp;MiB</b> is used
instead. (The values <b>0</b> and <b>max</b> aren&rsquo;t
affected by this. A similar feature doesn&rsquo;t exist for
decompression.) This can be helpful when a 32-bit executable
has access to 4&nbsp;GiB address space (2 GiB on MIPS32)
while hopefully doing no harm in other situations.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="52%">


<p style="margin-top: 1em">See also the section <b>Memory
usage</b>.</p> </td>
<td width="26%">
</td></tr>
</table>


<p style="margin-left:11%;"><b>--memlimit-decompress=</b><i>limit</i></p>

<p style="margin-left:22%;">Set a memory usage limit for
decompression. This also affects the <b>--list</b> mode. If
the operation is not possible without exceeding the
<i>limit</i>, <b>xz</b> will display an error and
decompressing the file will fail. See
<b>--memlimit-compress=</b><i>limit</i> for possible ways to
specify the <i>limit</i>.</p>


<p style="margin-left:11%;"><b>--memlimit-mt-decompress=</b><i>limit</i></p>

<p style="margin-left:22%;">Set a memory usage limit for
multi-threaded decompression. This can only affect the
number of threads; this will never make <b>xz</b> refuse to
decompress a file. If <i>limit</i> is too low to allow any
multi-threading, the <i>limit</i> is ignored and <b>xz</b>
will continue in single-threaded mode. Note that if also
<b>--memlimit-decompress</b> is used, it will always apply
to both single-threaded and multi-threaded modes, and so the
effective <i>limit</i> for multi-threading will never be
higher than the limit set with
<b>--memlimit-decompress</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p>In contrast to the other memory usage limit options,
<b>--memlimit-mt-decompress=</b><i>limit</i> has a
system-specific default <i>limit</i>. <b>xz
--info-memory</b> can be used to see the current value.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p>This option and its default value exist because without
any limit the threaded decompressor could end up allocating
an insane amount of memory with some input files. If the
default <i>limit</i> is too low on your system, feel free to
increase the <i>limit</i> but never set it to a value larger
than the amount of usable RAM as with appropriate input
files <b>xz</b> will attempt to use that amount of memory
even with a low number of threads. Running out of memory or
swapping will not improve decompression performance.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p>See <b>--memlimit-compress=</b><i>limit</i> for possible
ways to specify the <i>limit</i>. Setting <i>limit</i> to
<b>0</b> resets the <i>limit</i> to the default
system-specific value.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="89%">


<p><b>-M</b> <i>limit</i>, <b>--memlimit=</b><i>limit</i>,
<b>--memory=</b><i>limit</i></p> </td></tr>
</table>

<p style="margin-left:22%;">This is equivalent to
specifying <b>--memlimit-compress=</b><i>limit</i>
<b>--memlimit-decompress=</b><i>limit</i>
<b>--memlimit-mt-decompress=</b><i>limit</i>.</p>

<p style="margin-left:11%;"><b>--no-adjust</b></p>

<p style="margin-left:22%;">Display an error and exit if
the memory usage limit cannot be met without adjusting
settings that affect the compressed output. That is, this
prevents <b>xz</b> from switching the encoder from
multi-threaded mode to single-threaded mode and from
reducing the LZMA2 dictionary size. Even when this option is
used the number of threads may be reduced to meet the memory
usage limit as that won&rsquo;t affect the compressed
output.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p>Automatic adjusting is always disabled when creating raw
streams (<b>--format=raw</b>).</p></td></tr>
</table>

<p style="margin-left:11%;"><b>-T</b> <i>threads</i>,
<b>--threads=</b><i>threads</i></p>

<p style="margin-left:22%;">Specify the number of worker
threads to use. Setting <i>threads</i> to a special value
<b>0</b> makes <b>xz</b> use up to as many threads as the
processor(s) on the system support. The actual number of
threads can be fewer than <i>threads</i> if the input file
is not big enough for threading with the given settings or
if using more threads would exceed the memory usage
limit.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p>The single-threaded and multi-threaded compressors
produce different output. Single-threaded compressor will
give the smallest file size but only the output from the
multi-threaded compressor can be decompressed using multiple
threads. Setting <i>threads</i> to <b>1</b> will use the
single-threaded mode. Setting <i>threads</i> to any other
value, including <b>0</b>, will use the multi-threaded
compressor even if the system supports only one hardware
thread. (<b>xz</b> 5.2.x used single-threaded mode in this
situation.)</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p>To use multi-threaded mode with only one thread, set
<i>threads</i> to <b>+1</b>. The <b>+</b> prefix has no
effect with values other than <b>1</b>. A memory usage limit
can still make <b>xz</b> switch to single-threaded mode
unless <b>--no-adjust</b> is used. Support for the <b>+</b>
prefix was added in <b>xz</b> 5.4.0.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p>If an automatic number of threads has been requested and
no memory usage limit has been specified, then a
system-specific default soft limit will be used to possibly
limit the number of threads. It is a soft limit in sense
that it is ignored if the number of threads becomes one,
thus a soft limit will never stop <b>xz</b> from compressing
or decompressing. This default soft limit will not make
<b>xz</b> switch from multi-threaded mode to single-threaded
mode. The active limits can be seen with <b>xz
--info-memory</b>.</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p>Currently the only threading method is to split the
input into blocks and compress them independently from each
other. The default block size depends on the compression
level and can be overridden with the
<b>--block-size=</b><i>size</i> option.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p>Threaded decompression only works on files that contain
multiple blocks with size information in block headers. All
large enough files compressed in multi-threaded mode meet
this condition, but files compressed in single-threaded mode
don&rsquo;t even if <b>--block-size=</b><i>size</i> has been
used.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Custom
compressor filter chains</b> <br>
A custom filter chain allows specifying the compression
settings in detail instead of relying on the settings
associated to the presets. When a custom filter chain is
specified, preset options (<b>-0</b> ... <b>-9</b> and
<b>--extreme</b>) earlier on the command line are forgotten.
If a preset option is specified after one or more custom
filter chain options, the new preset takes effect and the
custom filter chain options specified earlier are
forgotten.</p>

<p style="margin-left:11%; margin-top: 1em">A filter chain
is comparable to piping on the command line. When
compressing, the uncompressed input goes to the first
filter, whose output goes to the next filter (if any). The
output of the last filter gets written to the compressed
file. The maximum number of filters in the chain is four,
but typically a filter chain has only one or two
filters.</p>

<p style="margin-left:11%; margin-top: 1em">Many filters
have limitations on where they can be in the filter chain:
some filters can work only as the last filter in the chain,
some only as a non-last filter, and some work in any
position in the chain. Depending on the filter, this
limitation is either inherent to the filter design or exists
to prevent security issues.</p>

<p style="margin-left:11%; margin-top: 1em">A custom filter
chain is specified by using one or more filter options in
the order they are wanted in the filter chain. That is, the
order of filter options is significant! When decoding raw
streams (<b>--format=raw</b>), the filter chain is specified
in the same order as it was specified when compressing.</p>

<p style="margin-left:11%; margin-top: 1em">Filters take
filter-specific <i>options</i> as a comma-separated list.
Extra commas in <i>options</i> are ignored. Every option has
a default value, so you need to specify only those you want
to change.</p>

<p style="margin-left:11%; margin-top: 1em">To see the
whole filter chain and <i>options</i>, use <b>xz -vv</b>
(that is, use <b>--verbose</b> twice). This works also for
viewing the filter chain options used by presets. <b><br>
--lzma1</b>[<b>=</b><i>options</i>] <b><br>
--lzma2</b>[<b>=</b><i>options</i>]</p>

<p style="margin-left:22%;">Add LZMA1 or LZMA2 filter to
the filter chain. These filters can be used only as the last
filter in the chain.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p>LZMA1 is a legacy filter, which is supported almost
solely due to the legacy <b>.lzma</b> file format, which
supports only LZMA1. LZMA2 is an updated version of LZMA1 to
fix some practical issues of LZMA1. The <b>.xz</b> format
uses LZMA2 and doesn&rsquo;t support LZMA1 at all.
Compression speed and ratios of LZMA1 and LZMA2 are
practically the same.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p>LZMA1 and LZMA2 share the same set of
<i>options</i>:</p> </td></tr>
</table>


<p style="margin-left:22%;"><b>preset=</b><i>preset</i></p>

<p style="margin-left:32%;">Reset all LZMA1 or LZMA2
<i>options</i> to <i>preset</i>. <i>Preset</i> consist of an
integer, which may be followed by single-letter preset
modifiers. The integer can be from <b>0</b> to <b>9</b>,
matching the command line options <b>-0</b> ... <b>-9</b>.
The only supported modifier is currently <b>e</b>, which
matches <b>--extreme</b>. If no <b>preset</b> is specified,
the default values of LZMA1 or LZMA2 <i>options</i> are
taken from the preset <b>6</b>.</p>

<p style="margin-left:22%;"><b>dict=</b><i>size</i></p>

<p style="margin-left:32%;">Dictionary (history buffer)
<i>size</i> indicates how many bytes of the recently
processed uncompressed data is kept in memory. The algorithm
tries to find repeating byte sequences (matches) in the
uncompressed data, and replace them with references to the
data currently in the dictionary. The bigger the dictionary,
the higher is the chance to find a match. Thus, increasing
dictionary <i>size</i> usually improves compression ratio,
but a dictionary bigger than the uncompressed file is waste
of memory.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">
</td>
<td width="3%"></td>
<td width="68%">


<p>Typical dictionary <i>size</i> is from 64&nbsp;KiB to
64&nbsp;MiB. The minimum is 4&nbsp;KiB. The maximum for
compression is currently 1.5&nbsp;GiB (1536&nbsp;MiB). The
decompressor already supports dictionaries up to one byte
less than 4&nbsp;GiB, which is the maximum for the LZMA1 and
LZMA2 stream formats.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">
</td>
<td width="3%"></td>
<td width="68%">


<p>Dictionary <i>size</i> and match finder (<i>mf</i>)
together determine the memory usage of the LZMA1 or LZMA2
encoder. The same (or bigger) dictionary <i>size</i> is
required for decompressing that was used when compressing,
thus the memory usage of the decoder is determined by the
dictionary size used when compressing. The <b>.xz</b>
headers store the dictionary <i>size</i> either as
2^<i>n</i> or 2^<i>n</i> + 2^(<i>n</i>-1), so these
<i>sizes</i> are somewhat preferred for compression. Other
<i>sizes</i> will get rounded up when stored in the
<b>.xz</b> headers.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><b>lc=</b><i>lc</i></p></td>
<td width="3%"></td>
<td width="68%">


<p>Specify the number of literal context bits. The minimum
is 0 and the maximum is 4; the default is 3. In addition,
the sum of <i>lc</i> and <i>lp</i> must not exceed 4.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">
</td>
<td width="3%"></td>
<td width="68%">


<p>All bytes that cannot be encoded as matches are encoded
as literals. That is, literals are simply 8-bit bytes that
are encoded one at a time.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">
</td>
<td width="3%"></td>
<td width="68%">


<p>The literal coding makes an assumption that the highest
<i>lc</i> bits of the previous uncompressed byte correlate
with the next byte. For example, in typical English text, an
upper-case letter is often followed by a lower-case letter,
and a lower-case letter is usually followed by another
lower-case letter. In the US-ASCII character set, the
highest three bits are 010 for upper-case letters and 011
for lower-case letters. When <i>lc</i> is at least 3, the
literal coding can take advantage of this property in the
uncompressed data.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">
</td>
<td width="3%"></td>
<td width="68%">


<p>The default value (3) is usually good. If you want
maximum compression, test <b>lc=4</b>. Sometimes it helps a
little, and sometimes it makes compression worse. If it
makes it worse, test <b>lc=2</b> too.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><b>lp=</b><i>lp</i></p></td>
<td width="3%"></td>
<td width="68%">


<p>Specify the number of literal position bits. The minimum
is 0 and the maximum is 4; the default is 0.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">
</td>
<td width="3%"></td>
<td width="68%">


<p><i>Lp</i> affects what kind of alignment in the
uncompressed data is assumed when encoding literals. See
<i>pb</i> below for more information about alignment.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><b>pb=</b><i>pb</i></p></td>
<td width="3%"></td>
<td width="68%">


<p>Specify the number of position bits. The minimum is 0
and the maximum is 4; the default is 2.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">
</td>
<td width="3%"></td>
<td width="68%">


<p><i>Pb</i> affects what kind of alignment in the
uncompressed data is assumed in general. The default means
four-byte alignment (2^<i>pb</i>=2^2=4), which is often a
good choice when there&rsquo;s no better guess.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">
</td>
<td width="3%"></td>
<td width="68%">


<p>When the alignment is known, setting <i>pb</i>
accordingly may reduce the file size a little. For example,
with text files having one-byte alignment (US-ASCII,
ISO-8859-*, UTF-8), setting <b>pb=0</b> can improve
compression slightly. For UTF-16 text, <b>pb=1</b> is a good
choice. If the alignment is an odd number like 3 bytes,
<b>pb=0</b> might be the best choice.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">
</td>
<td width="3%"></td>
<td width="68%">


<p>Even though the assumed alignment can be adjusted with
<i>pb</i> and <i>lp</i>, LZMA1 and LZMA2 still slightly
favor 16-byte alignment. It might be worth taking into
account when designing file formats that are likely to be
often compressed with LZMA1 or LZMA2.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">


<p><b>mf=</b><i>mf</i></p></td>
<td width="3%"></td>
<td width="68%">


<p>Match finder has a major effect on encoder speed, memory
usage, and compression ratio. Usually Hash Chain match
finders are faster than Binary Tree match finders. The
default depends on the <i>preset</i>: 0 uses <b>hc3</b>,
1&ndash;3 use <b>hc4</b>, and the rest use <b>bt4</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="7%">
</td>
<td width="3%"></td>
<td width="68%">


<p>The following match finders are supported. The memory
usage formulas below are rough approximations, which are
closest to the reality when <i>dict</i> is a power of
two.</p> </td></tr>
</table>

<p style="margin-left:32%;"><b>hc3</b></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="43%"></td>
<td width="57%">


<p style="margin-top: 1em">Hash Chain with 2- and 3-byte
hashing</p> </td></tr>
</table>

<p style="margin-left:43%;">Minimum value for <i>nice</i>:
3 <br>
Memory usage: <i><br>
dict</i> * 7.5 (if <i>dict</i> &lt;= 16 MiB); <i><br>
dict</i> * 5.5 + 64 MiB (if <i>dict</i> &gt; 16 MiB)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="32%"></td>
<td width="5%">


<p style="margin-top: 1em"><b>hc4</b></p></td>
<td width="6%"></td>
<td width="57%">


<p style="margin-top: 1em">Hash Chain with 2-, 3-, and
4-byte hashing</p></td></tr>
</table>

<p style="margin-left:43%;">Minimum value for <i>nice</i>:
4 <br>
Memory usage: <i><br>
dict</i> * 7.5 (if <i>dict</i> &lt;= 32 MiB); <i><br>
dict</i> * 6.5 (if <i>dict</i> &gt; 32 MiB)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="32%"></td>
<td width="5%">


<p style="margin-top: 1em"><b>bt2</b></p></td>
<td width="6%"></td>
<td width="48%">


<p style="margin-top: 1em">Binary Tree with 2-byte
hashing</p> </td>
<td width="9%">
</td></tr>
</table>

<p style="margin-left:43%;">Minimum value for <i>nice</i>:
2 <br>
Memory usage: <i>dict</i> * 9.5</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="32%"></td>
<td width="5%">


<p style="margin-top: 1em"><b>bt3</b></p></td>
<td width="6%"></td>
<td width="57%">


<p style="margin-top: 1em">Binary Tree with 2- and 3-byte
hashing</p> </td></tr>
</table>

<p style="margin-left:43%;">Minimum value for <i>nice</i>:
3 <br>
Memory usage: <i><br>
dict</i> * 11.5 (if <i>dict</i> &lt;= 16 MiB); <i><br>
dict</i> * 9.5 + 64 MiB (if <i>dict</i> &gt; 16 MiB)</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="32%"></td>
<td width="5%">


<p style="margin-top: 1em"><b>bt4</b></p></td>
<td width="6%"></td>
<td width="57%">


<p style="margin-top: 1em">Binary Tree with 2-, 3-, and
4-byte hashing</p></td></tr>
</table>

<p style="margin-left:43%;">Minimum value for <i>nice</i>:
4 <br>
Memory usage: <i><br>
dict</i> * 11.5 (if <i>dict</i> &lt;= 32 MiB); <i><br>
dict</i> * 10.5 (if <i>dict</i> &gt; 32 MiB)</p>

<p style="margin-left:22%;"><b>mode=</b><i>mode</i></p>

<p style="margin-left:32%;">Compression <i>mode</i>
specifies the method to analyze the data produced by the
match finder. Supported <i>modes</i> are <b>fast</b> and
<b>normal</b>. The default is <b>fast</b> for <i>presets</i>
0&ndash;3 and <b>normal</b> for <i>presets</i>
4&ndash;9.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="32%"></td>
<td width="68%">


<p>Usually <b>fast</b> is used with Hash Chain match
finders and <b>normal</b> with Binary Tree match finders.
This is also what the <i>presets</i> do.</p></td></tr>
</table>

<p style="margin-left:22%;"><b>nice=</b><i>nice</i></p>

<p style="margin-left:32%;">Specify what is considered to
be a nice length for a match. Once a match of at least
<i>nice</i> bytes is found, the algorithm stops looking for
possibly better matches.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="32%"></td>
<td width="68%">


<p><i>Nice</i> can be 2&ndash;273 bytes. Higher values tend
to give better compression ratio at the expense of speed.
The default depends on the <i>preset</i>.</p></td></tr>
</table>

<p style="margin-left:22%;"><b>depth=</b><i>depth</i></p>

<p style="margin-left:32%;">Specify the maximum search
depth in the match finder. The default is the special value
of 0, which makes the compressor determine a reasonable
<i>depth</i> from <i>mf</i> and <i>nice</i>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p>Reasonable <i>depth</i> for Hash Chains is 4&ndash;100
and 16&ndash;1000 for Binary Trees. Using very high values
for <i>depth</i> can make the encoder extremely slow with
some files. Avoid setting the <i>depth</i> over 1000 unless
you are prepared to interrupt the compression in case it is
taking far too long.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p>When decoding raw streams (<b>--format=raw</b>), LZMA2
needs only the dictionary <i>size</i>. LZMA1 needs also
<i>lc</i>, <i>lp</i>, and <i>pb</i>.</p></td></tr>
</table>


<p style="margin-left:11%;"><b>--x86</b>[<b>=</b><i>options</i>]
<b><br>
--arm</b>[<b>=</b><i>options</i>] <b><br>
--armthumb</b>[<b>=</b><i>options</i>] <b><br>
--arm64</b>[<b>=</b><i>options</i>] <b><br>
--powerpc</b>[<b>=</b><i>options</i>] <b><br>
--ia64</b>[<b>=</b><i>options</i>] <b><br>
--sparc</b>[<b>=</b><i>options</i>]</p>

<p style="margin-left:22%;">Add a branch/call/jump (BCJ)
filter to the filter chain. These filters can be used only
as a non-last filter in the filter chain.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p>A BCJ filter converts relative addresses in the machine
code to their absolute counterparts. This doesn&rsquo;t
change the size of the data but it increases redundancy,
which can help LZMA2 to produce 0&ndash;15&nbsp;% smaller
<b>.xz</b> file. The BCJ filters are always reversible, so
using a BCJ filter for wrong type of data doesn&rsquo;t
cause any data loss, although it may make the compression
ratio slightly worse. The BCJ filters are very fast and use
an insignificant amount of memory.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p>These BCJ filters have known problems related to the
compression ratio:</p></td></tr>
</table>

<p style="margin-left:22%;">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%"></td>
<td width="3%"></td>
<td width="74%">


<p style="margin-top: 1em">Some types of files containing
executable code (for example, object files, static
libraries, and Linux kernel modules) have the addresses in
the instructions filled with filler values. These BCJ
filters will still do the address conversion, which will
make the compression worse with these files.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="74%">


<p>If a BCJ filter is applied on an archive, it is possible
that it makes the compression ratio worse than not using a
BCJ filter. For example, if there are similar or even
identical executables then filtering will likely make the
files less similar and thus compression is worse. The
contents of non-executable files in the same archive can
matter too. In practice one has to try with and without a
BCJ filter to see which is better in each situation.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">Different
instruction sets have different alignment: the executable
file must be aligned to a multiple of this value in the
input data to make the filter work.</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-207323.png" alt="Image grohtml-207323.png"></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p style="margin-top: 1em">Since the BCJ-filtered data is
usually compressed with LZMA2, the compression ratio may be
improved slightly if the LZMA2 options are set to match the
alignment of the selected BCJ filter. For example, with the
IA-64 filter, it&rsquo;s good to set <b>pb=4</b> or even
<b>pb=4,lp=4,lc=0</b> with LZMA2 (2^4=16). The x86 filter is
an exception; it&rsquo;s usually good to stick to
LZMA2&rsquo;s default four-byte alignment when compressing
x86 executables.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p>All BCJ filters support the same <i>options</i>:</p></td></tr>
</table>

<p style="margin-left:22%;"><b>start=</b><i>offset</i></p>

<p style="margin-left:32%;">Specify the start <i>offset</i>
that is used when converting between relative and absolute
addresses. The <i>offset</i> must be a multiple of the
alignment of the filter (see the table above). The default
is zero. In practice, the default is good; specifying a
custom <i>offset</i> is almost never useful.</p>


<p style="margin-left:11%;"><b>--delta</b>[<b>=</b><i>options</i>]</p>

<p style="margin-left:22%;">Add the Delta filter to the
filter chain. The Delta filter can be only used as a
non-last filter in the filter chain.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p>Currently only simple byte-wise delta calculation is
supported. It can be useful when compressing, for example,
uncompressed bitmap images or uncompressed PCM audio.
However, special purpose algorithms may give significantly
better results than Delta + LZMA2. This is true especially
with audio, which compresses faster and better, for example,
with <b>flac</b>(1).</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p>Supported <i>options</i>:</p></td></tr>
</table>


<p style="margin-left:22%;"><b>dist=</b><i>distance</i></p>

<p style="margin-left:32%;">Specify the <i>distance</i> of
the delta calculation in bytes. <i>distance</i> must be
1&ndash;256. The default is 1.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="32%"></td>
<td width="68%">


<p>For example, with <b>dist=2</b> and eight-byte input A1
B1 A2 B3 A3 B5 A4 B7, the output will be A1 B1 01 02 01 02
01 02.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em"><b>Other
options <br>
-q</b>, <b>--quiet</b></p>

<p style="margin-left:22%;">Suppress warnings and notices.
Specify this twice to suppress errors too. This option has
no effect on the exit status. That is, even if a warning was
suppressed, the exit status to indicate a warning is still
used.</p>

<p style="margin-left:11%;"><b>-v</b>, <b>--verbose</b></p>

<p style="margin-left:22%;">Be verbose. If standard error
is connected to a terminal, <b>xz</b> will display a
progress indicator. Specifying <b>--verbose</b> twice will
give even more verbose output.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p>The progress indicator shows the following
information:</p> </td></tr>
</table>

<p style="margin-left:22%;">&bull;</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%"></td>
<td width="3%"></td>
<td width="74%">


<p style="margin-top: 1em">Completion percentage is shown
if the size of the input file is known. That is, the
percentage cannot be shown in pipes.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="74%">


<p>Amount of compressed data produced (compressing) or
consumed (decompressing).</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="74%">


<p>Amount of uncompressed data consumed (compressing) or
produced (decompressing).</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="74%">


<p>Compression ratio, which is calculated by dividing the
amount of compressed data processed so far by the amount of
uncompressed data processed so far.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="74%">


<p>Compression or decompression speed. This is measured as
the amount of uncompressed data consumed (compression) or
produced (decompression) per second. It is shown after a few
seconds have passed since <b>xz</b> started processing the
file.</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="74%">


<p>Elapsed time in the format M:SS or H:MM:SS.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="1%">


<p>&bull;</p></td>
<td width="3%"></td>
<td width="74%">


<p>Estimated remaining time is shown only when the size of
the input file is known and a couple of seconds have already
passed since <b>xz</b> started processing the file. The time
is shown in a less precise format which never has any
colons, for example, 2 min 30 s.</p></td></tr>
</table>

<p style="margin-left:22%; margin-top: 1em">When standard
error is not a terminal, <b>--verbose</b> will make
<b>xz</b> print the filename, compressed size, uncompressed
size, compression ratio, and possibly also the speed and
elapsed time on a single line to standard error after
compressing or decompressing the file. The speed and elapsed
time are included only when the operation took at least a
few seconds. If the operation didn&rsquo;t finish, for
example, due to user interruption, also the completion
percentage is printed if the size of the input file is
known.</p>

<p style="margin-left:11%;"><b>-Q</b>, <b>--no-warn</b></p>

<p style="margin-left:22%;">Don&rsquo;t set the exit status
to 2 even if a condition worth a warning was detected. This
option doesn&rsquo;t affect the verbosity level, thus both
<b>--quiet</b> and <b>--no-warn</b> have to be used to not
display warnings and to not alter the exit status.</p>

<p style="margin-left:11%;"><b>--robot</b></p>

<p style="margin-left:22%;">Print messages in a
machine-parsable format. This is intended to ease writing
frontends that want to use <b>xz</b> instead of liblzma,
which may be the case with various scripts. The output with
this option enabled is meant to be stable across <b>xz</b>
releases. See the section <b>ROBOT MODE</b> for details.</p>

<p style="margin-left:11%;"><b>--info-memory</b></p>

<p style="margin-left:22%;">Display, in human-readable
format, how much physical memory (RAM) and how many
processor threads <b>xz</b> thinks the system has and the
memory usage limits for compression and decompression, and
exit successfully.</p>

<p style="margin-left:11%;"><b>-h</b>, <b>--help</b></p>

<p style="margin-left:22%;">Display a help message
describing the most commonly used options, and exit
successfully.</p>

<p style="margin-left:11%;"><b>-H</b>,
<b>--long-help</b></p>

<p style="margin-left:22%;">Display a help message
describing all features of <b>xz</b>, and exit
successfully</p>

<p style="margin-left:11%;"><b>-V</b>, <b>--version</b></p>

<p style="margin-left:22%;">Display the version number of
<b>xz</b> and liblzma in human readable format. To get
machine-parsable output, specify <b>--robot</b> before
<b>--version</b>.</p>

<h2>ROBOT MODE
<a name="ROBOT MODE"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The robot mode
is activated with the <b>--robot</b> option. It makes the
output of <b>xz</b> easier to parse by other programs.
Currently <b>--robot</b> is supported only together with
<b>--version</b>, <b>--info-memory</b>, and <b>--list</b>.
It will be supported for compression and decompression in
the future.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Version <br>
xz --robot --version</b> will print the version number of
<b>xz</b> and liblzma in the following format:</p>


<p style="margin-left:11%; margin-top: 1em"><b>XZ_VERSION=</b><i>XYYYZZZS</i>
<b><br>
LIBLZMA_VERSION=</b><i>XYYYZZZS</i></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><i>X</i></p></td>
<td width="7%"></td>
<td width="78%">


<p>Major version.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><i>YYY</i></p></td>
<td width="7%"></td>
<td width="78%">


<p>Minor version. Even numbers are stable. Odd numbers are
alpha or beta versions.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><i>ZZZ</i></p></td>
<td width="7%"></td>
<td width="78%">


<p>Patch level for stable releases or just a counter for
development releases.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="4%">


<p><i>S</i></p></td>
<td width="7%"></td>
<td width="78%">


<p>Stability. 0 is alpha, 1 is beta, and 2 is stable.
<i>S</i> should be always 2 when <i>YYY</i> is even.</p></td></tr>
</table>


<p style="margin-left:11%; margin-top: 1em"><i>XYYYZZZS</i>
are the same on both lines if <b>xz</b> and liblzma are from
the same XZ Utils release.</p>

<p style="margin-left:11%; margin-top: 1em">Examples:
4.999.9beta is <b>49990091</b> and 5.0.0 is
<b>50000002</b>.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Memory limit
information <br>
xz --robot --info-memory</b> prints a single line with three
tab-separated columns:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p style="margin-top: 1em">1.</p></td>
<td width="3%"></td>
<td width="83%">


<p style="margin-top: 1em">Total amount of physical memory
(RAM) in bytes.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>2.</p></td>
<td width="3%"></td>
<td width="83%">


<p>Memory usage limit for compression in bytes
(<b>--memlimit-compress</b>). A special value of <b>0</b>
indicates the default setting which for single-threaded mode
is the same as no limit.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>3.</p></td>
<td width="3%"></td>
<td width="83%">


<p>Memory usage limit for decompression in bytes
(<b>--memlimit-decompress</b>). A special value of <b>0</b>
indicates the default setting which for single-threaded mode
is the same as no limit.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>4.</p></td>
<td width="3%"></td>
<td width="83%">


<p>Since <b>xz</b> 5.3.4alpha: Memory usage for
multi-threaded decompression in bytes
(<b>--memlimit-mt-decompress</b>). This is never zero
because a system-specific default value shown in the column
5 is used if no limit has been specified explicitly. This is
also never greater than the value in the column 3 even if a
larger value has been specified with
<b>--memlimit-mt-decompress</b>.</p> </td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>5.</p></td>
<td width="3%"></td>
<td width="83%">


<p>Since <b>xz</b> 5.3.4alpha: A system-specific default
memory usage limit that is used to limit the number of
threads when compressing with an automatic number of threads
(<b>--threads=0</b>) and no memory usage limit has been
specified (<b>--memlimit-compress</b>). This is also used as
the default value for <b>--memlimit-mt-decompress</b>.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="3%">


<p>6.</p></td>
<td width="3%"></td>
<td width="83%">


<p>Since <b>xz</b> 5.3.4alpha: Number of available
processor threads.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">In the future,
the output of <b>xz --robot --info-memory</b> may have more
columns, but never more than a single line.</p>

<p style="margin-left:11%; margin-top: 1em"><b>List mode
<br>
xz --robot --list</b> uses tab-separated output. The first
column of every line has a string that indicates the type of
the information found on that line:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p style="margin-top: 1em"><b>name</b></p></td>
<td width="2%"></td>
<td width="78%">


<p style="margin-top: 1em">This is always the first line
when starting to list a file. The second column on the line
is the filename.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>file</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>This line contains overall information about the
<b>.xz</b> file. This line is always printed after the
<b>name</b> line.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>stream</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>This line type is used only when <b>--verbose</b> was
specified. There are as many <b>stream</b> lines as there
are streams in the <b>.xz</b> file.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>block</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>This line type is used only when <b>--verbose</b> was
specified. There are as many <b>block</b> lines as there are
blocks in the <b>.xz</b> file. The <b>block</b> lines are
shown after all the <b>stream</b> lines; different line
types are not interleaved.</p></td></tr>
</table>

<p style="margin-left:11%;"><b>summary</b></p>

<p style="margin-left:22%;">This line type is used only
when <b>--verbose</b> was specified twice. This line is
printed after all <b>block</b> lines. Like the <b>file</b>
line, the <b>summary</b> line contains overall information
about the <b>.xz</b> file.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>totals</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>This line is always the very last line of the list
output. It shows the total counts and sizes.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The columns of
the <b>file</b> lines:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p style="margin-top: 1em">2.</p></td>
<td width="3%"></td>
<td width="72%">


<p style="margin-top: 1em">Number of streams in the
file</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p>3.</p></td>
<td width="3%"></td>
<td width="72%">


<p>Total number of blocks in the stream(s)</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p>4.</p></td>
<td width="3%"></td>
<td width="72%">


<p>Compressed size of the file</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p>5.</p></td>
<td width="3%"></td>
<td width="72%">


<p>Uncompressed size of the file</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p>6.</p></td>
<td width="3%"></td>
<td width="72%">


<p>Compression ratio, for example, <b>0.123</b>. If ratio
is over 9.999, three dashes (<b>---</b>) are displayed
instead of the ratio.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p>7.</p></td>
<td width="3%"></td>
<td width="72%">


<p>Comma-separated list of integrity check names. The
following strings are used for the known check types:
<b>None</b>, <b>CRC32</b>, <b>CRC64</b>, and <b>SHA-256</b>.
For unknown check types, <b>Unknown-</b><i>N</i> is used,
where <i>N</i> is the Check ID as a decimal number (one or
two digits).</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p>8.</p></td>
<td width="3%"></td>
<td width="72%">


<p>Total size of stream padding in the file</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The columns of
the <b>stream</b> lines:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="4%">


<p style="margin-top: 1em">2.</p></td>
<td width="2%"></td>
<td width="72%">


<p style="margin-top: 1em">Stream number (the first stream
is 1)</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="4%">


<p>3.</p></td>
<td width="2%"></td>
<td width="72%">


<p>Number of blocks in the stream</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="4%">


<p>4.</p></td>
<td width="2%"></td>
<td width="72%">


<p>Compressed start offset</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="4%">


<p>5.</p></td>
<td width="2%"></td>
<td width="72%">


<p>Uncompressed start offset</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="4%">


<p>6.</p></td>
<td width="2%"></td>
<td width="72%">


<p>Compressed size (does not include stream padding)</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="4%">


<p>7.</p></td>
<td width="2%"></td>
<td width="72%">


<p>Uncompressed size</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="4%">


<p>8.</p></td>
<td width="2%"></td>
<td width="72%">


<p>Compression ratio</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="4%">


<p>9.</p></td>
<td width="2%"></td>
<td width="72%">


<p>Name of the integrity check</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="4%">


<p>10.</p></td>
<td width="2%"></td>
<td width="72%">


<p>Size of stream padding</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The columns of
the <b>block</b> lines:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="4%">


<p style="margin-top: 1em">2.</p></td>
<td width="2%"></td>
<td width="72%">


<p style="margin-top: 1em">Number of the stream containing
this block</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="4%">


<p>3.</p></td>
<td width="2%"></td>
<td width="72%">


<p>Block number relative to the beginning of the stream
(the first block is 1)</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="4%">


<p>4.</p></td>
<td width="2%"></td>
<td width="72%">


<p>Block number relative to the beginning of the file</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="4%">


<p>5.</p></td>
<td width="2%"></td>
<td width="72%">


<p>Compressed start offset relative to the beginning of the
file</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="4%">


<p>6.</p></td>
<td width="2%"></td>
<td width="72%">


<p>Uncompressed start offset relative to the beginning of
the file</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="4%">


<p>7.</p></td>
<td width="2%"></td>
<td width="72%">


<p>Total compressed size of the block (includes
headers)</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="4%">


<p>8.</p></td>
<td width="2%"></td>
<td width="72%">


<p>Uncompressed size</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="4%">


<p>9.</p></td>
<td width="2%"></td>
<td width="72%">


<p>Compression ratio</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="4%">


<p>10.</p></td>
<td width="2%"></td>
<td width="72%">


<p>Name of the integrity check</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">If
<b>--verbose</b> was specified twice, additional columns are
included on the <b>block</b> lines. These are not displayed
with a single <b>--verbose</b>, because getting this
information requires many seeks and can thus be slow:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="4%">


<p style="margin-top: 1em">11.</p></td>
<td width="2%"></td>
<td width="72%">


<p style="margin-top: 1em">Value of the integrity check in
hexadecimal</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="4%">


<p>12.</p></td>
<td width="2%"></td>
<td width="72%">


<p>Block header size</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="4%">


<p>13.</p></td>
<td width="2%"></td>
<td width="72%">


<p>Block flags: <b>c</b> indicates that compressed size is
present, and <b>u</b> indicates that uncompressed size is
present. If the flag is not set, a dash (<b>-</b>) is shown
instead to keep the string length fixed. New flags may be
added to the end of the string in the future.</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="4%">


<p>14.</p></td>
<td width="2%"></td>
<td width="72%">


<p>Size of the actual compressed data in the block (this
excludes the block header, block padding, and check
fields)</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="4%">


<p>15.</p></td>
<td width="2%"></td>
<td width="72%">


<p>Amount of memory (in bytes) required to decompress this
block with this <b>xz</b> version</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="4%">


<p>16.</p></td>
<td width="2%"></td>
<td width="72%">


<p>Filter chain. Note that most of the options used at
compression time cannot be known, because only the options
that are needed for decompression are stored in the
<b>.xz</b> headers.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The columns of
the <b>summary</b> lines:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p style="margin-top: 1em">2.</p></td>
<td width="3%"></td>
<td width="72%">


<p style="margin-top: 1em">Amount of memory (in bytes)
required to decompress this file with this <b>xz</b>
version</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p>3.</p></td>
<td width="3%"></td>
<td width="72%">


<p><b>yes</b> or <b>no</b> indicating if all block headers
have both compressed size and uncompressed size stored in
them</p> </td></tr>
</table>

<p style="margin-left:22%;"><i>Since</i> <b>xz</b>
<i>5.1.2alpha:</i></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p style="margin-top: 1em">4.</p></td>
<td width="3%"></td>
<td width="72%">


<p style="margin-top: 1em">Minimum <b>xz</b> version
required to decompress the file</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">The columns of
the <b>totals</b> line:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p style="margin-top: 1em">2.</p></td>
<td width="3%"></td>
<td width="72%">


<p style="margin-top: 1em">Number of streams</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p>3.</p></td>
<td width="3%"></td>
<td width="72%">


<p>Number of blocks</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p>4.</p></td>
<td width="3%"></td>
<td width="72%">


<p>Compressed size</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p>5.</p></td>
<td width="3%"></td>
<td width="72%">


<p>Uncompressed size</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p>6.</p></td>
<td width="3%"></td>
<td width="72%">


<p>Average compression ratio</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p>7.</p></td>
<td width="3%"></td>
<td width="72%">


<p>Comma-separated list of integrity check names that were
present in the files</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p>8.</p></td>
<td width="3%"></td>
<td width="72%">


<p>Stream padding size</p></td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="3%">


<p>9.</p></td>
<td width="3%"></td>
<td width="72%">


<p>Number of files. This is here to keep the order of the
earlier columns the same as on <b>file</b> lines.</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">If
<b>--verbose</b> was specified twice, additional columns are
included on the <b>totals</b> line:</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="4%">


<p style="margin-top: 1em">10.</p></td>
<td width="2%"></td>
<td width="72%">


<p style="margin-top: 1em">Maximum amount of memory (in
bytes) required to decompress the files with this <b>xz</b>
version</p> </td></tr>
<tr valign="top" align="left">
<td width="22%"></td>
<td width="4%">


<p>11.</p></td>
<td width="2%"></td>
<td width="72%">


<p><b>yes</b> or <b>no</b> indicating if all block headers
have both compressed size and uncompressed size stored in
them</p> </td></tr>
</table>

<p style="margin-left:22%;"><i>Since</i> <b>xz</b>
<i>5.1.2alpha:</i></p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="4%">


<p style="margin-top: 1em">12.</p></td>
<td width="2%"></td>
<td width="72%">


<p style="margin-top: 1em">Minimum <b>xz</b> version
required to decompress the file</p></td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Future versions
may add new line types and new columns can be added to the
existing line types, but the existing columns won&rsquo;t be
changed.</p>

<h2>EXIT STATUS
<a name="EXIT STATUS"></a>
</h2>


<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p style="margin-top: 1em"><b>0</b></p></td>
<td width="10%"></td>
<td width="78%">


<p style="margin-top: 1em">All is good.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p><b>1</b></p></td>
<td width="10%"></td>
<td width="78%">


<p>An error occurred.</p></td></tr>
<tr valign="top" align="left">
<td width="11%"></td>
<td width="1%">


<p><b>2</b></p></td>
<td width="10%"></td>
<td width="78%">


<p>Something worth a warning occurred, but no actual errors
occurred.</p> </td></tr>
</table>

<p style="margin-left:11%; margin-top: 1em">Notices (not
warnings or errors) printed on standard error don&rsquo;t
affect the exit status.</p>

<h2>ENVIRONMENT
<a name="ENVIRONMENT"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>xz</b>
parses space-separated lists of options from the environment
variables <b>XZ_DEFAULTS</b> and <b>XZ_OPT</b>, in this
order, before parsing the options from the command line.
Note that only options are parsed from the environment
variables; all non-options are silently ignored. Parsing is
done with <b>getopt_long</b>(3) which is used also for the
command line arguments. <b><br>
XZ_DEFAULTS</b></p>

<p style="margin-left:22%;">User-specific or system-wide
default options. Typically this is set in a shell
initialization script to enable <b>xz</b>&rsquo;s memory
usage limiter by default. Excluding shell initialization
scripts and similar special cases, scripts must never set or
unset <b>XZ_DEFAULTS</b>.</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="11%"></td>
<td width="9%">


<p><b>XZ_OPT</b></p></td>
<td width="2%"></td>
<td width="78%">


<p>This is for passing options to <b>xz</b> when it is not
possible to set the options directly on the <b>xz</b>
command line. This is the case when <b>xz</b> is run by a
script or tool, for example, GNU <b>tar</b>(1):</p></td></tr>
</table>

<p style="margin-left:32%; margin-top: 1em">XZ_OPT=-2v tar
caf foo.tar.xz foo</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="22%"></td>
<td width="78%">


<p style="margin-top: 1em">Scripts may use <b>XZ_OPT</b>,
for example, to set script-specific default compression
options. It is still recommended to allow users to override
<b>XZ_OPT</b> if that is reasonable. For example, in
<b>sh</b>(1) scripts one may use something like this:</p></td></tr>
</table>


<p style="margin-left:32%; margin-top: 1em">XZ_OPT=${XZ_OPT-&quot;-7e&quot;}
<br>
export XZ_OPT</p>

<h2>LZMA UTILS COMPATIBILITY
<a name="LZMA UTILS COMPATIBILITY"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em">The command
line syntax of <b>xz</b> is practically a superset of
<b>lzma</b>, <b>unlzma</b>, and <b>lzcat</b> as found from
LZMA Utils 4.32.x. In most cases, it is possible to replace
LZMA Utils with XZ Utils without breaking existing scripts.
There are some incompatibilities though, which may sometimes
cause problems.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Compression
preset levels</b> <br>
The numbering of the compression level presets is not
identical in <b>xz</b> and LZMA Utils. The most important
difference is how dictionary sizes are mapped to different
presets. Dictionary size is roughly equal to the
decompressor memory usage.</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-207324.png" alt="Image grohtml-207324.png"></p>

<p style="margin-left:11%; margin-top: 1em">The dictionary
size differences affect the compressor memory usage too, but
there are some other differences between LZMA Utils and XZ
Utils, which make the difference even bigger:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-207325.png" alt="Image grohtml-207325.png"></p>

<p style="margin-left:11%; margin-top: 1em">The default
preset level in LZMA Utils is <b>-7</b> while in XZ Utils it
is <b>-6</b>, so both use an 8 MiB dictionary by
default.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Streamed vs.
non-streamed .lzma files</b> <br>
The uncompressed size of the file can be stored in the
<b>.lzma</b> header. LZMA Utils does that when compressing
regular files. The alternative is to mark that uncompressed
size is unknown and use end-of-payload marker to indicate
where the decompressor should stop. LZMA Utils uses this
method when uncompressed size isn&rsquo;t known, which is
the case, for example, in pipes.</p>

<p style="margin-left:11%; margin-top: 1em"><b>xz</b>
supports decompressing <b>.lzma</b> files with or without
end-of-payload marker, but all <b>.lzma</b> files created by
<b>xz</b> will use end-of-payload marker and have
uncompressed size marked as unknown in the <b>.lzma</b>
header. This may be a problem in some uncommon situations.
For example, a <b>.lzma</b> decompressor in an embedded
device might work only with files that have known
uncompressed size. If you hit this problem, you need to use
LZMA Utils or LZMA SDK to create <b>.lzma</b> files with
known uncompressed size.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Unsupported
.lzma files</b> <br>
The <b>.lzma</b> format allows <i>lc</i> values up to 8, and
<i>lp</i> values up to 4. LZMA Utils can decompress files
with any <i>lc</i> and <i>lp</i>, but always creates files
with <b>lc=3</b> and <b>lp=0</b>. Creating files with other
<i>lc</i> and <i>lp</i> is possible with <b>xz</b> and with
LZMA SDK.</p>

<p style="margin-left:11%; margin-top: 1em">The
implementation of the LZMA1 filter in liblzma requires that
the sum of <i>lc</i> and <i>lp</i> must not exceed 4. Thus,
<b>.lzma</b> files, which exceed this limitation, cannot be
decompressed with <b>xz</b>.</p>

<p style="margin-left:11%; margin-top: 1em">LZMA Utils
creates only <b>.lzma</b> files which have a dictionary size
of 2^<i>n</i> (a power of 2) but accepts files with any
dictionary size. liblzma accepts only <b>.lzma</b> files
which have a dictionary size of 2^<i>n</i> or 2^<i>n</i> +
2^(<i>n</i>-1). This is to decrease false positives when
detecting <b>.lzma</b> files.</p>

<p style="margin-left:11%; margin-top: 1em">These
limitations shouldn&rsquo;t be a problem in practice, since
practically all <b>.lzma</b> files have been compressed with
settings that liblzma will accept.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Trailing
garbage</b> <br>
When decompressing, LZMA Utils silently ignore everything
after the first <b>.lzma</b> stream. In most situations,
this is a bug. This also means that LZMA Utils don&rsquo;t
support decompressing concatenated <b>.lzma</b> files.</p>

<p style="margin-left:11%; margin-top: 1em">If there is
data left after the first <b>.lzma</b> stream, <b>xz</b>
considers the file to be corrupt unless
<b>--single-stream</b> was used. This may break obscure
scripts which have assumed that trailing garbage is
ignored.</p>

<h2>NOTES
<a name="NOTES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Compressed
output may vary</b> <br>
The exact compressed output produced from the same
uncompressed input file may vary between XZ Utils versions
even if compression options are identical. This is because
the encoder can be improved (faster or better compression)
without affecting the file format. The output can vary even
between different builds of the same XZ Utils version, if
different build options are used.</p>

<p style="margin-left:11%; margin-top: 1em">The above means
that once <b>--rsyncable</b> has been implemented, the
resulting files won&rsquo;t necessarily be rsyncable unless
both old and new files have been compressed with the same xz
version. This problem can be fixed if a part of the encoder
implementation is frozen to keep rsyncable output stable
across xz versions.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Embedded .xz
decompressors</b> <br>
Embedded <b>.xz</b> decompressor implementations like XZ
Embedded don&rsquo;t necessarily support files created with
integrity <i>check</i> types other than <b>none</b> and
<b>crc32</b>. Since the default is <b>--check=crc64</b>, you
must use <b>--check=none</b> or <b>--check=crc32</b> when
creating files for embedded systems.</p>

<p style="margin-left:11%; margin-top: 1em">Outside
embedded systems, all <b>.xz</b> format decompressors
support all the <i>check</i> types, or at least are able to
decompress the file without verifying the integrity check if
the particular <i>check</i> is not supported.</p>

<p style="margin-left:11%; margin-top: 1em">XZ Embedded
supports BCJ filters, but only with the default start
offset.</p>

<h2>EXAMPLES
<a name="EXAMPLES"></a>
</h2>


<p style="margin-left:11%; margin-top: 1em"><b>Basics</b>
<br>
Compress the file <i>foo</i> into <i>foo.xz</i> using the
default compression level (<b>-6</b>), and remove <i>foo</i>
if compression is successful:</p>

<p style="margin-left:22%; margin-top: 1em">xz foo</p>

<p style="margin-left:11%; margin-top: 1em">Decompress
<i>bar.xz</i> into <i>bar</i> and don&rsquo;t remove
<i>bar.xz</i> even if decompression is successful:</p>

<p style="margin-left:22%; margin-top: 1em">xz -dk
bar.xz</p>

<p style="margin-left:11%; margin-top: 1em">Create
<i>baz.tar.xz</i> with the preset <b>-4e</b> (<b>-4
--extreme</b>), which is slower than the default <b>-6</b>,
but needs less memory for compression and decompression
(48&nbsp;MiB and 5&nbsp;MiB, respectively):</p>

<p style="margin-left:22%; margin-top: 1em">tar cf - baz |
xz -4e &gt; baz.tar.xz</p>

<p style="margin-left:11%; margin-top: 1em">A mix of
compressed and uncompressed files can be decompressed to
standard output with a single command:</p>

<p style="margin-left:22%; margin-top: 1em">xz -dcf a.txt
b.txt.xz c.txt d.txt.lzma &gt; abcd.txt</p>

<p style="margin-left:11%; margin-top: 1em"><b>Parallel
compression of many files</b> <br>
On GNU and *BSD, <b>find</b>(1) and <b>xargs</b>(1) can be
used to parallelize compression of many files:</p>

<p style="margin-left:22%; margin-top: 1em">find . -type f
\! -name &rsquo;*.xz&rsquo; -print0 \ <br>
| xargs -0r -P4 -n16 xz -T1</p>

<p style="margin-left:11%; margin-top: 1em">The <b>-P</b>
option to <b>xargs</b>(1) sets the number of parallel
<b>xz</b> processes. The best value for the <b>-n</b> option
depends on how many files there are to be compressed. If
there are only a couple of files, the value should probably
be 1; with tens of thousands of files, 100 or even more may
be appropriate to reduce the number of <b>xz</b> processes
that <b>xargs</b>(1) will eventually create.</p>

<p style="margin-left:11%; margin-top: 1em">The option
<b>-T1</b> for <b>xz</b> is there to force it to
single-threaded mode, because <b>xargs</b>(1) is used to
control the amount of parallelization.</p>

<p style="margin-left:11%; margin-top: 1em"><b>Robot
mode</b> <br>
Calculate how many bytes have been saved in total after
compressing multiple files:</p>

<p style="margin-left:22%; margin-top: 1em">xz --robot
--list *.xz | awk &rsquo;/^totals/{print $5-$4}&rsquo;</p>

<p style="margin-left:11%; margin-top: 1em">A script may
want to know that it is using new enough <b>xz</b>. The
following <b>sh</b>(1) script checks that the version number
of the <b>xz</b> tool is at least 5.0.0. This method is
compatible with old beta versions, which didn&rsquo;t
support the <b>--robot</b> option:</p>

<p style="margin-left:22%; margin-top: 1em">if ! eval
&quot;$(xz --robot --version 2&gt; /dev/null)&quot; || <br>
[ &quot;$XZ_VERSION&quot; -lt 50000002 ]; then <br>
echo &quot;Your xz is too old.&quot; <br>
fi <br>
unset XZ_VERSION LIBLZMA_VERSION</p>

<p style="margin-left:11%; margin-top: 1em">Set a memory
usage limit for decompression using <b>XZ_OPT</b>, but if a
limit has already been set, don&rsquo;t increase it:</p>

<p style="margin-left:22%; margin-top: 1em">NEWLIM=$((123
&lt;&lt; 20))&nbsp;&nbsp;# 123 MiB <br>
OLDLIM=$(xz --robot --info-memory | cut -f3) <br>
if [ $OLDLIM -eq 0 -o $OLDLIM -gt $NEWLIM ]; then <br>
XZ_OPT=&quot;$XZ_OPT --memlimit-decompress=$NEWLIM&quot;
<br>
export XZ_OPT <br>
fi</p>

<p style="margin-left:11%; margin-top: 1em"><b>Custom
compressor filter chains</b> <br>
The simplest use for custom filter chains is customizing a
LZMA2 preset. This can be useful, because the presets cover
only a subset of the potentially useful combinations of
compression settings.</p>

<p style="margin-left:11%; margin-top: 1em">The CompCPU
columns of the tables from the descriptions of the options
<b>-0</b> ... <b>-9</b> and <b>--extreme</b> are useful when
customizing LZMA2 presets. Here are the relevant parts
collected from those two tables:</p>


<p align="center" style="margin-top: 1em"><img src="grohtml-207326.png" alt="Image grohtml-207326.png"></p>

<p style="margin-left:11%; margin-top: 1em">If you know
that a file requires somewhat big dictionary (for example,
32&nbsp;MiB) to compress well, but you want to compress it
quicker than <b>xz -8</b> would do, a preset with a low
CompCPU value (for example, 1) can be modified to use a
bigger dictionary:</p>

<p style="margin-left:22%; margin-top: 1em">xz
--lzma2=preset=1,dict=32MiB foo.tar</p>

<p style="margin-left:11%; margin-top: 1em">With certain
files, the above command may be faster than <b>xz -6</b>
while compressing significantly better. However, it must be
emphasized that only some files benefit from a big
dictionary while keeping the CompCPU value low. The most
obvious situation, where a big dictionary can help a lot, is
an archive containing very similar files of at least a few
megabytes each. The dictionary size has to be significantly
bigger than any individual file to allow LZMA2 to take full
advantage of the similarities between consecutive files.</p>

<p style="margin-left:11%; margin-top: 1em">If very high
compressor and decompressor memory usage is fine, and the
file being compressed is at least several hundred megabytes,
it may be useful to use an even bigger dictionary than the
64 MiB that <b>xz -9</b> would use:</p>

<p style="margin-left:22%; margin-top: 1em">xz -vv
--lzma2=dict=192MiB big_foo.tar</p>

<p style="margin-left:11%; margin-top: 1em">Using
<b>-vv</b> (<b>--verbose --verbose</b>) like in the above
example can be useful to see the memory requirements of the
compressor and decompressor. Remember that using a
dictionary bigger than the size of the uncompressed file is
waste of memory, so the above command isn&rsquo;t useful for
small files.</p>

<p style="margin-left:11%; margin-top: 1em">Sometimes the
compression time doesn&rsquo;t matter, but the decompressor
memory usage has to be kept low, for example, to make it
possible to decompress the file on an embedded system. The
following command uses <b>-6e</b> (<b>-6 --extreme</b>) as a
base and sets the dictionary to only 64&nbsp;KiB. The
resulting file can be decompressed with XZ Embedded
(that&rsquo;s why there is <b>--check=crc32</b>) using about
100&nbsp;KiB of memory.</p>

<p style="margin-left:22%; margin-top: 1em">xz
--check=crc32 --lzma2=preset=6e,dict=64KiB foo</p>

<p style="margin-left:11%; margin-top: 1em">If you want to
squeeze out as many bytes as possible, adjusting the number
of literal context bits (<i>lc</i>) and number of position
bits (<i>pb</i>) can sometimes help. Adjusting the number of
literal position bits (<i>lp</i>) might help too, but
usually <i>lc</i> and <i>pb</i> are more important. For
example, a source code archive contains mostly US-ASCII
text, so something like the following might give slightly
(like 0.1&nbsp;%) smaller file than <b>xz -6e</b> (try also
without <b>lc=4</b>):</p>

<p style="margin-left:22%; margin-top: 1em">xz
--lzma2=preset=6e,pb=0,lc=4 source_code.tar</p>

<p style="margin-left:11%; margin-top: 1em">Using another
filter together with LZMA2 can improve compression with
certain file types. For example, to compress a x86-32 or
x86-64 shared library using the x86 BCJ filter:</p>

<p style="margin-left:22%; margin-top: 1em">xz --x86
--lzma2 libfoo.so</p>

<p style="margin-left:11%; margin-top: 1em">Note that the
order of the filter options is significant. If <b>--x86</b>
is specified after <b>--lzma2</b>, <b>xz</b> will give an
error, because there cannot be any filter after LZMA2, and
also because the x86 BCJ filter cannot be used as the last
filter in the chain.</p>

<p style="margin-left:11%; margin-top: 1em">The Delta
filter together with LZMA2 can give good results with bitmap
images. It should usually beat PNG, which has a few more
advanced filters than simple delta but uses Deflate for the
actual compression.</p>

<p style="margin-left:11%; margin-top: 1em">The image has
to be saved in uncompressed format, for example, as
uncompressed TIFF. The distance parameter of the Delta
filter is set to match the number of bytes per pixel in the
image. For example, 24-bit RGB bitmap needs <b>dist=3</b>,
and it is also good to pass <b>pb=0</b> to LZMA2 to
accommodate the three-byte alignment:</p>

<p style="margin-left:22%; margin-top: 1em">xz
--delta=dist=3 --lzma2=pb=0 foo.tiff</p>

<p style="margin-left:11%; margin-top: 1em">If multiple
images have been put into a single archive (for example,
<b>.tar</b>), the Delta filter will work on that too as long
as all images have the same number of bytes per pixel.</p>

<h2>SEE ALSO
<a name="SEE ALSO"></a>
</h2>



<p style="margin-left:11%; margin-top: 1em"><b>xzdec</b>(1),
<b>xzdiff</b>(1), <b>xzgrep</b>(1), <b>xzless</b>(1),
<b>xzmore</b>(1), <b>gzip</b>(1), <b>bzip2</b>(1),
<b>7z</b>(1)</p>

<p style="margin-left:11%; margin-top: 1em">XZ Utils:
&lt;https://tukaani.org/xz/&gt; <br>
XZ Embedded: &lt;https://tukaani.org/xz/embedded.html&gt;
<br>
LZMA SDK: &lt;http://7-zip.org/sdk.html&gt;</p>
<hr>
</body>
</html>
