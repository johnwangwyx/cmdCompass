<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Thu May  9 06:34:47 2024 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>DASH(1) BSD General Commands Manual DASH(1)</p>

<p style="margin-top: 1em"><b>NAME</b></p>

<p style="margin-left:6%;"><b>dash</b> &mdash; command
interpreter (shell)</p>

<p style="margin-top: 1em"><b>SYNOPSIS</b></p>

<p style="margin-left:13%;"><b>dash</b>
[<b>-aCefnuvxIimqVEbp</b>] [<b>+aCefnuvxIimqVEbp</b>]
[<b>-o&nbsp;</b><i>option_name</i>]
[<b>+o&nbsp;</b><i>option_name</i>]
[<i>command_file&nbsp;</i>[</p>

<p><i>argument&nbsp;...</i> ]]</p>

<p style="margin-left:13%;"><b>dash -c</b>
[<b>-aCefnuvxIimqVEbp</b>] [<b>+aCefnuvxIimqVEbp</b>]
[<b>-o&nbsp;</b><i>option_name</i>]
[<b>+o&nbsp;</b><i>option_name</i>] <i>command_string</i>
[<i>command_name&nbsp;</i>[</p>

<p><i>argument&nbsp;...</i> ]]</p>

<p style="margin-left:13%;"><b>dash -s</b>
[<b>-aCefnuvxIimqVEbp</b>] [<b>+aCefnuvxIimqVEbp</b>]
[<b>-o&nbsp;</b><i>option_name</i>]
[<b>+o&nbsp;</b><i>option_name</i>]
[<i>argument&nbsp;...</i>]</p>

<p style="margin-top: 1em"><b>DESCRIPTION</b></p>

<p style="margin-left:6%;"><b>dash</b> is the standard
command interpreter for the system. The current version of
<b>dash</b> is in the process of being changed to conform
with the POSIX 1003.2 and 1003.2a specifications for the
shell. This version has many features which make it appear
similar in some respects to the Korn shell, but it is not a
Korn shell clone (see ksh(1)). Only features designated by
POSIX, plus a few Berkeley extensions, are being
incorporated into this shell. This man page is not intended
to be a tutorial or a complete specification of the
shell.</p>

<p style="margin-left:6%; margin-top: 1em"><b>Overview</b>
<br>
The shell is a command that reads lines from either a file
or the terminal, interprets them, and generally executes
other commands. It is the program that is running when a
user logs into the system (although a user can select a
different shell with the chsh(1) command). The shell
implements a language that has flow control constructs, a
macro facility that provides a variety of features in
addition to data storage, along with built in history and
line editing capabilities. It incorporates many features to
aid interactive use and has the advantage that the
interpretative language is common to both interactive and
non-interactive use (shell scripts). That is, commands can
be typed directly to the running shell or can be put into a
file and the file can be executed directly by the shell.</p>


<p style="margin-left:6%; margin-top: 1em"><b>Invocation</b>
<br>
If no args are present and if the standard input of the
shell is connected to a terminal (or if the <b>-i</b> flag
is set), and the <b>-c</b> option is not present, the shell
is considered an interactive shell. An interactive shell
generally prompts before each command and handles
programming and command errors differently (as described
below). When first starting, the shell inspects argument 0,
and if it begins with a dash &rsquo;-&rsquo;, the shell is
also considered a login shell. This is normally done
automatically by the system when the user first logs in. A
login shell first reads commands from the files
<i>/etc/profile</i> and <i>.profile</i> if they exist. If
the environment variable ENV is set on entry to an
interactive shell, or is set in the <i>.profile</i> of a
login shell, the shell next reads commands from the file
named in ENV. Therefore, a user should place commands that
are to be executed only at login time in the <i>.profile</i>
file, and commands that are executed for every interactive
shell inside the ENV file. To set the ENV variable to some
file, place the following line in your <i>.profile</i> of
your home directory</p>


<p style="margin-left:14%; margin-top: 1em">ENV=$HOME/.shinit;
export ENV</p>

<p style="margin-left:6%; margin-top: 1em">substituting for
&ldquo;.shinit&rdquo; any filename you wish.</p>

<p style="margin-left:6%; margin-top: 1em">If command line
arguments besides the options have been specified, then the
shell treats the first argument as the name of a file from
which to read commands (a shell script), and the remaining
arguments are set as the positional parameters of the shell
($1, $2, etc). Otherwise, the shell reads commands from its
standard input.</p>

<p style="margin-left:6%; margin-top: 1em"><b>Argument List
Processing</b> <br>
All of the single letter options that have a corresponding
name can be used as an argument to the <b>-o</b> option. The
set <b>-o</b> name is provided next to the single letter
option in the description below. Specifying a dash
&ldquo;-&rdquo; turns the option on, while using a plus
&ldquo;+&rdquo; disables the option. The following options
can be set from the command line or with the <b>set</b>
builtin (described later).</p>

<p style="margin-top: 1em"><b>-a</b> <i>allexport</i></p>

<p style="margin-left:36%; margin-top: 1em">Export all
variables assigned to.</p>

<p style="margin-top: 1em"><b>-c</b></p>

<p style="margin-left:36%; margin-top: 1em">Read commands
from the <i>command_string</i> operand instead of from the
standard input. Special parameter 0 will be set from the
<i>command_name</i> operand and the positional parameters
($1, $2, etc.) set from the remaining argument operands.</p>

<p style="margin-top: 1em"><b>-C</b> <i>noclobber</i></p>

<p style="margin-left:36%; margin-top: 1em">Don&rsquo;t
overwrite existing files with &ldquo;&gt;&rdquo;.</p>

<p style="margin-top: 1em"><b>-e</b> <i>errexit</i></p>

<p style="margin-left:36%; margin-top: 1em">If not
interactive, exit immediately if any untested command fails.
The exit status of a command is considered to be explicitly
tested if the command is used to control an <b>if</b>,
<b>elif</b>, <b>while</b>, or <b>until</b>; or if the
command is the left hand operand of an
&ldquo;&amp;&amp;&rdquo; or &ldquo;||&rdquo; operator.</p>

<p style="margin-top: 1em"><b>-f</b> <i>noglob</i></p>

<p style="margin-left:36%; margin-top: 1em">Disable
pathname expansion.</p>

<p style="margin-top: 1em"><b>-n</b> <i>noexec</i></p>

<p style="margin-left:36%; margin-top: 1em">If not
interactive, read commands but do not execute them. This is
useful for checking the syntax of shell scripts.</p>

<p style="margin-top: 1em"><b>-u</b> <i>nounset</i></p>

<p style="margin-left:36%; margin-top: 1em">Write a message
to standard error when attempting to expand a variable that
is not set, and if the shell is not interactive, exit
immediately.</p>

<p style="margin-top: 1em"><b>-v</b> <i>verbose</i></p>

<p style="margin-left:36%; margin-top: 1em">The shell
writes its input to standard error as it is read. Useful for
debugging.</p>

<p style="margin-top: 1em"><b>-x</b> <i>xtrace</i></p>

<p style="margin-left:36%; margin-top: 1em">Write each
command to standard error (preceded by a
&rsquo;+&nbsp;&rsquo;) before it is executed. Useful for
debugging.</p>

<p style="margin-top: 1em"><b>-I</b> <i>ignoreeof</i></p>

<p style="margin-left:36%; margin-top: 1em">Ignore
EOF&rsquo;s from input when interactive.</p>

<p style="margin-top: 1em"><b>-i</b> <i>interactive</i></p>

<p style="margin-left:36%; margin-top: 1em">Force the shell
to behave interactively.</p>

<p style="margin-top: 1em"><b>-l</b></p>

<p style="margin-left:36%; margin-top: 1em">Make dash act
as if it had been invoked as a login shell.</p>

<p style="margin-top: 1em"><b>-m</b> <i>monitor</i></p>

<p style="margin-left:36%; margin-top: 1em">Turn on job
control (set automatically when interactive).</p>

<p style="margin-top: 1em"><b>-s</b> <i>stdin</i></p>

<p style="margin-left:36%; margin-top: 1em">Read commands
from standard input (set automatically if no file arguments
are present). This option has no effect when set after the
shell has already started running (i.e. with
<b>set</b>).</p>

<p style="margin-top: 1em"><b>-V</b> <i>vi</i></p>

<p style="margin-left:36%; margin-top: 1em">Enable the
built-in vi(1) command line editor (disables <b>-E</b> if it
has been set).</p>

<p style="margin-top: 1em"><b>-E</b> <i>emacs</i></p>

<p style="margin-left:36%; margin-top: 1em">Enable the
built-in emacs(1) command line editor (disables <b>-V</b> if
it has been set).</p>

<p style="margin-top: 1em"><b>-b</b> <i>notify</i></p>

<p style="margin-left:36%; margin-top: 1em">Enable
asynchronous notification of background job completion.
(UNIMPLEMENTED for 4.4alpha)</p>

<p style="margin-top: 1em"><b>-p</b> <i>priviliged</i></p>

<p style="margin-left:36%; margin-top: 1em">Do not attempt
to reset effective uid if it does not match uid. This is not
set by default to help avoid incorrect usage by setuid root
programs via system(3) or popen(3).</p>

<p style="margin-left:6%; margin-top: 1em"><b>Lexical
Structure</b> <br>
The shell reads input in terms of lines from a file and
breaks it up into words at whitespace (blanks and tabs), and
at certain sequences of characters that are special to the
shell called &ldquo;operators&rdquo;. There are two types of
operators: control operators and redirection operators
(their meaning is discussed later). Following is a list of
operators:</p>

<p style="margin-top: 1em">Control operators:</p>

<p style="margin-left:22%;">&amp; &amp;&amp; ( ) ; ;; | ||
&lt;newline&gt;</p>

<p style="margin-top: 1em">Redirection operators:</p>

<p style="margin-left:22%;">&lt; &gt; &gt;| &lt;&lt;
&gt;&gt; &lt;&amp; &gt;&amp; &lt;&lt;- &lt;&gt;</p>

<p style="margin-left:6%; margin-top: 1em"><b>Quoting</b>
<br>
Quoting is used to remove the special meaning of certain
characters or words to the shell, such as operators,
whitespace, or keywords. There are three types of quoting:
matched single quotes, matched double quotes, and
backslash.</p>


<p style="margin-left:6%; margin-top: 1em"><b>Backslash</b>
<br>
A backslash preserves the literal meaning of the following
character, with the exception of &lang; newline&rang; . A
backslash preceding a &lang; newline&rang; is treated as a
line continuation.</p>

<p style="margin-left:6%; margin-top: 1em"><b>Single
Quotes</b> <br>
Enclosing characters in single quotes preserves the literal
meaning of all the characters (except single quotes, making
it impossible to put single-quotes in a single-quoted
string).</p>

<p style="margin-left:6%; margin-top: 1em"><b>Double
Quotes</b> <br>
Enclosing characters within double quotes preserves the
literal meaning of all characters except dollarsign ($),
backquote (&rsquo;), and backslash (\). The backslash inside
double quotes is historically weird, and serves to quote
only the following characters:</p>

<p style="margin-left:14%;">$ &rsquo; &quot; \
&lt;newline&gt;.</p>

<p style="margin-left:6%;">Otherwise it remains
literal.</p>

<p style="margin-left:6%; margin-top: 1em"><b>Reserved
Words</b> <br>
Reserved words are words that have special meaning to the
shell and are recognized at the beginning of a line and
after a control operator. The following are reserved
words:</p>

<p style="margin-left:65%; margin-top: 1em">! elif fi while
case <br>
else for then { } <br>
do done until if esac</p>

<p style="margin-left:6%; margin-top: 1em">Their meaning is
discussed later.</p>

<p style="margin-left:6%; margin-top: 1em"><b>Aliases</b>
<br>
An alias is a name and corresponding value set using the
alias(1) builtin command. Whenever a reserved word may occur
(see above), and after checking for reserved words, the
shell checks the word to see if it matches an alias. If it
does, it replaces it in the input stream with its value. For
example, if there is an alias called &ldquo;lf&rdquo; with
the value &ldquo;ls -F&rdquo;, then the input:</p>

<p style="margin-left:14%; margin-top: 1em">lf foobar
&lang; return&rang;</p>

<p style="margin-left:6%; margin-top: 1em">would become</p>

<p style="margin-left:14%; margin-top: 1em">ls -F foobar
&lang; return&rang;</p>

<p style="margin-left:6%; margin-top: 1em">Aliases provide
a convenient way for naive users to create shorthands for
commands without having to learn how to create functions
with arguments. They can also be used to create lexically
obscure code. This use is discouraged.</p>

<p style="margin-left:6%; margin-top: 1em"><b>Commands</b>
<br>
The shell interprets the words it reads according to a
language, the specification of which is outside the scope of
this man page (refer to the BNF in the POSIX 1003.2
document). Essentially though, a line is read and if the
first word of the line (or after a control operator) is not
a reserved word, then the shell has recognized a simple
command. Otherwise, a complex command or some other special
construct may have been recognized.</p>

<p style="margin-left:6%; margin-top: 1em"><b>Simple
Commands</b> <br>
If a simple command has been recognized, the shell performs
the following actions:</p>

<p style="margin-top: 1em">1.</p>

<p style="margin-left:21%;">Leading words of the form
&ldquo;name=value&rdquo; are stripped off and assigned to
the environment of the simple command. Redirection operators
and their arguments (as described below) are stripped off
and saved for processing.</p>

<p style="margin-top: 1em">2.</p>

<p style="margin-left:21%;">The remaining words are
expanded as described in the section called
&ldquo;Expansions&rdquo;, and the first remaining word is
considered the command name and the command is located. The
remaining words are considered the arguments of the command.
If no command name resulted, then the
&ldquo;name=value&rdquo; variable assignments recognized in
item 1 affect the current shell.</p>

<p style="margin-top: 1em">3.</p>

<p style="margin-left:21%;">Redirections are performed as
described in the next section.</p>


<p style="margin-left:6%; margin-top: 1em"><b>Redirections</b>
<br>
Redirections are used to change where a command reads its
input or sends its output. In general, redirections open,
close, or duplicate an existing reference to a file. The
overall format used for redirection is:</p>

<p style="margin-left:14%; margin-top: 1em">[n] <i>redir-op
file</i></p>

<p style="margin-left:6%; margin-top: 1em">where
<i>redir-op</i> is one of the redirection operators
mentioned previously. Following is a list of the possible
redirections. The [n] is an optional number between 0 and 9,
as in &rsquo;3&rsquo; (not &rsquo;[3]&rsquo;), that refers
to a file descriptor.</p>

<p style="margin-top: 1em">[n]&gt; file</p>

<p style="margin-left:29%; margin-top: 1em">Redirect
standard output (or n) to file.</p>

<p style="margin-top: 1em">[n]&gt;| file</p>

<p style="margin-left:29%; margin-top: 1em">Same, but
override the <b>-C</b> option.</p>

<p style="margin-top: 1em">[n]&gt;&gt; file</p>

<p style="margin-left:29%; margin-top: 1em">Append standard
output (or n) to file.</p>

<p style="margin-top: 1em">[n]&lt; file</p>

<p style="margin-left:29%; margin-top: 1em">Redirect
standard input (or n) from file.</p>

<p style="margin-top: 1em">[n1]&lt;&amp;n2</p>

<p style="margin-left:29%; margin-top: 1em">Copy file
descriptor n2 as stdout (or fd n1). fd n2.</p>

<p style="margin-top: 1em">[n]&lt;&amp;-</p>

<p style="margin-left:29%; margin-top: 1em">Close standard
input (or n).</p>

<p style="margin-top: 1em">[n1]&gt;&amp;n2</p>

<p style="margin-left:29%; margin-top: 1em">Copy file
descriptor n2 as stdin (or fd n1). fd n2.</p>

<p style="margin-top: 1em">[n]&gt;&amp;-</p>

<p style="margin-left:29%; margin-top: 1em">Close standard
output (or n).</p>

<p style="margin-top: 1em">[n]&lt;&gt; file</p>

<p style="margin-left:29%; margin-top: 1em">Open file for
reading and writing on standard input (or n).</p>

<p style="margin-left:6%; margin-top: 1em">The following
redirection is often called a
&ldquo;here-document&rdquo;.</p>

<p style="margin-left:14%; margin-top: 1em">[n]&lt;&lt;
delimiter</p>

<p style="margin-left:22%;">here-doc-text ...</p>

<p style="margin-left:14%;">delimiter</p>

<p style="margin-left:6%; margin-top: 1em">All the text on
successive lines up to the delimiter is saved away and made
available to the command on standard input, or file
descriptor n if it is specified. If the delimiter as
specified on the initial line is quoted, then the
here-doc-text is treated literally, otherwise the text is
subjected to parameter expansion, command substitution, and
arithmetic expansion (as described in the section on
&ldquo;Expansions&rdquo;). If the operator is
&ldquo;&lt;&lt;-&rdquo; instead of &ldquo;&lt;&lt;&rdquo;,
then leading tabs in the here-doc-text are stripped.</p>

<p style="margin-left:6%; margin-top: 1em"><b>Search and
Execution</b> <br>
There are three types of commands: shell functions, builtin
commands, and normal programs &ndash; and the command is
searched for (by name) in that order. They each are executed
in a different way.</p>

<p style="margin-left:6%; margin-top: 1em">When a shell
function is executed, all of the shell positional parameters
(except $0, which remains unchanged) are set to the
arguments of the shell function. The variables which are
explicitly placed in the environment of the command (by
placing assignments to them before the function name) are
made local to the function and are set to the values given.
Then the command given in the function definition is
executed. The positional parameters are restored to their
original values when the command completes. This all occurs
within the current shell.</p>

<p style="margin-left:6%; margin-top: 1em">Shell builtins
are executed internally to the shell, without spawning a new
process.</p>

<p style="margin-left:6%; margin-top: 1em">Otherwise, if
the command name doesn&rsquo;t match a function or builtin,
the command is searched for as a normal program in the file
system (as described in the next section). When a normal
program is executed, the shell runs the program, passing the
arguments and the environment to the program. If the program
is not a normal executable file (i.e., if it does not begin
with the &quot;magic number&quot; whose ASCII representation
is &quot;#!&quot;, so execve(2) returns ENOEXEC then) the
shell will interpret the program in a subshell. The child
shell will reinitialize itself in this case, so that the
effect will be as if a new shell had been invoked to handle
the ad-hoc shell script, except that the location of hashed
commands located in the parent shell will be remembered by
the child.</p>

<p style="margin-left:6%; margin-top: 1em">Note that
previous versions of this document and the source code
itself misleadingly and sporadically refer to a shell script
without a magic number as a &quot;shell procedure&quot;.</p>

<p style="margin-left:6%; margin-top: 1em"><b>Path
Search</b> <br>
When locating a command, the shell first looks to see if it
has a shell function by that name. Then it looks for a
builtin command by that name. If a builtin command is not
found, one of two things happen:</p>

<p style="margin-top: 1em">1.</p>

<p style="margin-left:13%;">Command names containing a
slash are simply executed without performing any
searches.</p>

<p style="margin-top: 1em">2.</p>

<p style="margin-left:13%;">The shell searches each entry
in PATH in turn for the command. The value of the PATH
variable should be a series of entries separated by colons.
Each entry consists of a directory name. The current
directory may be indicated implicitly by an empty directory
name, or explicitly by a single period.</p>

<p style="margin-left:6%; margin-top: 1em"><b>Command Exit
Status</b> <br>
Each command has an exit status that can influence the
behaviour of other shell commands. The paradigm is that a
command exits with zero for normal or success, and non-zero
for failure, error, or a false indication. The man page for
each command should indicate the various exit codes and what
they mean. Additionally, the builtin commands return exit
codes, as does an executed shell function.</p>

<p style="margin-left:6%; margin-top: 1em">If a command
consists entirely of variable assignments then the exit
status of the command is that of the last command
substitution if any, otherwise 0.</p>

<p style="margin-left:6%; margin-top: 1em"><b>Complex
Commands</b> <br>
Complex commands are combinations of simple commands with
control operators or reserved words, together creating a
larger complex command. More generally, a command is one of
the following:</p>

<p style="margin-top: 1em"><b>&bull;</b></p>

<p style="margin-left:12%;">simple command</p>

<p style="margin-top: 1em"><b>&bull;</b></p>

<p style="margin-left:12%;">pipeline</p>

<p style="margin-top: 1em"><b>&bull;</b></p>

<p style="margin-left:12%;">list or compound-list</p>

<p style="margin-top: 1em"><b>&bull;</b></p>

<p style="margin-left:12%;">compound command</p>

<p style="margin-top: 1em"><b>&bull;</b></p>

<p style="margin-left:12%;">function definition</p>

<p style="margin-left:6%; margin-top: 1em">Unless otherwise
stated, the exit status of a command is that of the last
simple command executed by the command.</p>


<p style="margin-left:6%; margin-top: 1em"><b>Pipelines</b>
<br>
A pipeline is a sequence of one or more commands separated
by the control operator |. The standard output of all but
the last command is connected to the standard input of the
next command. The standard output of the last command is
inherited from the shell, as usual.</p>

<p style="margin-left:6%; margin-top: 1em">The format for a
pipeline is:</p>

<p style="margin-left:14%; margin-top: 1em">[!] command1 [|
command2 ...]</p>

<p style="margin-left:6%; margin-top: 1em">The standard
output of command1 is connected to the standard input of
command2. The standard input, standard output, or both of a
command is considered to be assigned by the pipeline before
any redirection specified by redirection operators that are
part of the command.</p>

<p style="margin-left:6%; margin-top: 1em">If the pipeline
is not in the background (discussed later), the shell waits
for all commands to complete.</p>

<p style="margin-left:6%; margin-top: 1em">If the reserved
word ! does not precede the pipeline, the exit status is the
exit status of the last command specified in the pipeline.
Otherwise, the exit status is the logical NOT of the exit
status of the last command. That is, if the last command
returns zero, the exit status is 1; if the last command
returns greater than zero, the exit status is zero.</p>

<p style="margin-left:6%; margin-top: 1em">Because pipeline
assignment of standard input or standard output or both
takes place before redirection, it can be modified by
redirection. For example:</p>

<p style="margin-left:14%; margin-top: 1em">$ command1
2&gt;&amp;1 | command2</p>

<p style="margin-left:6%; margin-top: 1em">sends both the
standard output and standard error of command1 to the
standard input of command2.</p>

<p style="margin-left:6%; margin-top: 1em">A ; or &lang;
newline&rang; terminator causes the preceding AND-OR-list
(described next) to be executed sequentially; a &amp; causes
asynchronous execution of the preceding AND-OR-list.</p>

<p style="margin-left:6%; margin-top: 1em">Note that unlike
some other shells, each process in the pipeline is a child
of the invoking shell (unless it is a shell builtin, in
which case it executes in the current shell &ndash; but any
effect it has on the environment is wiped).</p>

<p style="margin-left:6%; margin-top: 1em"><b>Background
Commands &ndash; &amp;</b> <br>
If a command is terminated by the control operator ampersand
(&amp;), the shell executes the command asynchronously
&ndash; that is, the shell does not wait for the command to
finish before executing the next command.</p>

<p style="margin-left:6%; margin-top: 1em">The format for
running a command in background is:</p>

<p style="margin-left:14%; margin-top: 1em">command1 &amp;
[command2 &amp; ...]</p>

<p style="margin-left:6%; margin-top: 1em">If the shell is
not interactive, the standard input of an asynchronous
command is set to <i>/dev/null</i>.</p>

<p style="margin-left:6%; margin-top: 1em"><b>Lists &ndash;
Generally Speaking</b> <br>
A list is a sequence of zero or more commands separated by
newlines, semicolons, or ampersands, and optionally
terminated by one of these three characters. The commands in
a list are executed in the order they are written. If
command is followed by an ampersand, the shell starts the
command and immediately proceeds onto the next command;
otherwise it waits for the command to terminate before
proceeding to the next one.</p>


<p style="margin-left:6%; margin-top: 1em"><b>Short-Circuit
List Operators</b> <br>
&ldquo;&amp;&amp;&rdquo; and &ldquo;||&rdquo; are AND-OR
list operators. &ldquo;&amp;&amp;&rdquo; executes the first
command, and then executes the second command if and only if
the exit status of the first command is zero.
&ldquo;||&rdquo; is similar, but executes the second command
if and only if the exit status of the first command is
nonzero. &ldquo;&amp;&amp;&rdquo; and &ldquo;||&rdquo; both
have the same priority.</p>

<p style="margin-left:6%; margin-top: 1em"><b>Flow-Control
Constructs &ndash; if, while, for, case</b> <br>
The syntax of the if command is</p>

<p style="margin-left:14%; margin-top: 1em">if list <br>
then list <br>
[ elif list <br>
then list ] ... <br>
[ else list ] <br>
fi</p>

<p style="margin-left:6%; margin-top: 1em">The syntax of
the while command is</p>

<p style="margin-left:14%; margin-top: 1em">while list <br>
do list <br>
done</p>

<p style="margin-left:6%; margin-top: 1em">The two lists
are executed repeatedly while the exit status of the first
list is zero. The until command is similar, but has the word
until in place of while, which causes it to repeat until the
exit status of the first list is zero.</p>

<p style="margin-left:6%; margin-top: 1em">The syntax of
the for command is</p>

<p style="margin-left:14%; margin-top: 1em">for variable [
in [ word ... ] ] <br>
do list <br>
done</p>

<p style="margin-left:6%; margin-top: 1em">The words
following <i>in</i> are expanded, and then the list is
executed repeatedly with the variable set to each word in
turn. Omitting in word ... is equivalent to in
&quot;$@&quot;.</p>

<p style="margin-left:6%; margin-top: 1em">The syntax of
the break and continue command is</p>

<p style="margin-left:14%; margin-top: 1em">break [ num ]
<br>
continue [ num ]</p>

<p style="margin-left:6%; margin-top: 1em">Break terminates
the num innermost for or while loops. Continue continues
with the next iteration of the innermost loop. These are
implemented as builtin commands.</p>

<p style="margin-left:6%; margin-top: 1em">The syntax of
the case command is</p>

<p style="margin-left:14%; margin-top: 1em">case word in
<br>
[(]pattern) list ;; <br>
... <br>
esac</p>

<p style="margin-left:6%; margin-top: 1em">The pattern can
actually be one or more patterns (see <i>Shell Patterns</i>
described later), separated by &ldquo;|&rdquo; characters.
The &ldquo;</p>

<p>( &rdquo; character before the pattern is optional.</p>

<p style="margin-left:6%; margin-top: 1em"><b>Grouping
Commands Together</b> <br>
Commands may be grouped by writing either</p>

<p style="margin-left:14%; margin-top: 1em">(list)</p>

<p style="margin-left:6%; margin-top: 1em">or</p>

<p style="margin-left:14%; margin-top: 1em">{ list; }</p>

<p style="margin-left:6%; margin-top: 1em">The first of
these executes the commands in a subshell. Builtin commands
grouped into a (list) will not affect the current shell. The
second form does not fork another shell so is slightly more
efficient. Grouping commands together this way allows you to
redirect their output as though they were one program:</p>

<p style="margin-left:14%; margin-top: 1em">{ printf &quot;
hello &quot; ; printf &quot; world\n&quot; ; } &gt;
greeting</p>

<p style="margin-left:6%; margin-top: 1em">Note that
&ldquo;}&rdquo; must follow a control operator (here,
&ldquo;;&rdquo;) so that it is recognized as a reserved word
and not as another command argument.</p>


<p style="margin-left:6%; margin-top: 1em"><b>Functions</b>
<br>
The syntax of a function definition is</p>

<p style="margin-left:14%; margin-top: 1em">name ()
command</p>

<p style="margin-left:6%; margin-top: 1em">A function
definition is an executable statement; when executed it
installs a function named name and returns an exit status of
zero. The command is normally a list enclosed between
&ldquo;{&rdquo; and &ldquo;}&rdquo;.</p>

<p style="margin-left:6%; margin-top: 1em">Variables may be
declared to be local to a function by using a local command.
This should appear as the first statement of a function, and
the syntax is</p>

<p style="margin-left:14%; margin-top: 1em">local [variable
| -] ...</p>

<p style="margin-left:6%; margin-top: 1em">Local is
implemented as a builtin command.</p>

<p style="margin-left:6%; margin-top: 1em">When a variable
is made local, it inherits the initial value and exported
and readonly flags from the variable with the same name in
the surrounding scope, if there is one. Otherwise, the
variable is initially unset. The shell uses dynamic scoping,
so that if you make the variable x local to function f,
which then calls function g, references to the variable x
made inside g will refer to the variable x declared inside
f, not to the global variable named x.</p>

<p style="margin-left:6%; margin-top: 1em">The only special
parameter that can be made local is &ldquo;-&rdquo;. Making
&ldquo;-&rdquo; local any shell options that are changed via
the set command inside the function to be restored to their
original values when the function returns.</p>

<p style="margin-left:6%; margin-top: 1em">The syntax of
the return command is</p>

<p style="margin-left:14%; margin-top: 1em">return
[exitstatus]</p>

<p style="margin-left:6%; margin-top: 1em">It terminates
the currently executing function. Return is implemented as a
builtin command.</p>

<p style="margin-left:6%; margin-top: 1em"><b>Variables and
Parameters</b> <br>
The shell maintains a set of parameters. A parameter denoted
by a name is called a variable. When starting up, the shell
turns all the environment variables into shell variables.
New variables can be set using the form</p>

<p style="margin-left:14%; margin-top: 1em">name=value</p>

<p style="margin-left:6%; margin-top: 1em">Variables set by
the user must have a name consisting solely of alphabetics,
numerics, and underscores - the first of which must not be
numeric. A parameter can also be denoted by a number or a
special character as explained below.</p>

<p style="margin-left:6%; margin-top: 1em"><b>Positional
Parameters</b> <br>
A positional parameter is a parameter denoted by a number (n
&gt; 0). The shell sets these initially to the values of its
command line arguments that follow the name of the shell
script. The <b>set</b> builtin can also be used to set or
reset them.</p>

<p style="margin-left:6%; margin-top: 1em"><b>Special
Parameters</b> <br>
A special parameter is a parameter denoted by one of the
following special characters. The value of the parameter is
listed next to its character.</p>

<p style="margin-top: 1em">*</p>

<p style="margin-left:23%; margin-top: 1em">Expands to the
positional parameters, starting from one. When the expansion
occurs within a double-quoted string it expands to a single
field with the value of each parameter separated by the
first character of the IFS variable, or by a &lang;
space&rang; if IFS is unset.</p>

<p style="margin-top: 1em">@</p>

<p style="margin-left:23%; margin-top: 1em">Expands to the
positional parameters, starting from one. When the expansion
occurs within double-quotes, each positional parameter
expands as a separate argument. If there are no positional
parameters, the expansion of @ generates zero arguments,
even when @ is double-quoted. What this basically means, for
example, is if $1 is &ldquo;abc&rdquo; and $2 is &ldquo;def
ghi&rdquo;, then &quot;$@&quot; expands to the two
arguments:</p>


<p style="margin-left:31%; margin-top: 1em">&quot;abc&quot;&nbsp;&quot;def&nbsp;ghi&quot;</p>

<p style="margin-top: 1em">#</p>

<p style="margin-left:23%; margin-top: 1em">Expands to the
number of positional parameters.</p>

<p style="margin-top: 1em">?</p>

<p style="margin-left:23%; margin-top: 1em">Expands to the
exit status of the most recent pipeline.</p>

<p style="margin-top: 1em">- (Hyphen.)</p>

<p style="margin-left:23%; margin-top: 1em">Expands to the
current option flags (the single-letter option names
concatenated into a string) as specified on invocation, by
the set builtin command, or implicitly by the shell.</p>

<p style="margin-top: 1em">$</p>

<p style="margin-left:23%; margin-top: 1em">Expands to the
process ID of the invoked shell. A subshell retains the same
value of $ as its parent.</p>

<p style="margin-top: 1em">!</p>

<p style="margin-left:23%; margin-top: 1em">Expands to the
process ID of the most recent background command executed
from the current shell. For a pipeline, the process ID is
that of the last command in the pipeline.</p>

<p style="margin-top: 1em">0 (Zero.)</p>

<p style="margin-left:23%; margin-top: 1em">Expands to the
name of the shell or shell script.</p>

<p style="margin-left:6%; margin-top: 1em"><b>Word
Expansions</b> <br>
This clause describes the various expansions that are
performed on words. Not all expansions are performed on
every word, as explained later.</p>

<p style="margin-left:6%; margin-top: 1em">Tilde
expansions, parameter expansions, command substitutions,
arithmetic expansions, and quote removals that occur within
a single word expand to a single field. It is only field
splitting or pathname expansion that can create multiple
fields from a single word. The single exception to this rule
is the expansion of the special parameter @ within
double-quotes, as was described above.</p>

<p style="margin-left:6%; margin-top: 1em">The order of
word expansion is:</p>

<p style="margin-top: 1em">1.</p>

<p style="margin-left:13%;">Tilde Expansion, Parameter
Expansion, Command Substitution, Arithmetic Expansion (these
all occur at the same time).</p>

<p style="margin-top: 1em">2.</p>

<p style="margin-left:13%;">Field Splitting is performed on
fields generated by step (1) unless the IFS variable is
null.</p>

<p style="margin-top: 1em">3.</p>

<p style="margin-left:13%;">Pathname Expansion (unless set
<b>-f</b> is in effect).</p>

<p style="margin-top: 1em">4.</p>

<p style="margin-left:13%;">Quote Removal.</p>

<p style="margin-left:6%; margin-top: 1em">The $ character
is used to introduce parameter expansion, command
substitution, or arithmetic evaluation.</p>

<p style="margin-left:6%; margin-top: 1em"><b>Tilde
Expansion (substituting a user&rsquo;s home directory)</b>
<br>
A word beginning with an unquoted tilde character (~) is
subjected to tilde expansion. All the characters up to a
slash (/) or the end of the word are treated as a username
and are replaced with the user&rsquo;s home directory. If
the username is missing (as in <i>~/foobar</i>), the tilde
is replaced with the value of the <i>HOME</i> variable (the
current user&rsquo;s home directory).</p>

<p style="margin-left:6%; margin-top: 1em"><b>Parameter
Expansion</b> <br>
The format for parameter expansion is as follows:</p>


<p style="margin-left:14%; margin-top: 1em">${expression}</p>

<p style="margin-left:6%; margin-top: 1em">where expression
consists of all characters until the matching
&ldquo;}&rdquo;. Any &ldquo;}&rdquo; escaped by a backslash
or within a quoted string, and characters in embedded
arithmetic expansions, command substitutions, and variable
expansions, are not examined in determining the matching
&ldquo;}&rdquo;.</p>

<p style="margin-left:6%; margin-top: 1em">The simplest
form for parameter expansion is:</p>


<p style="margin-left:14%; margin-top: 1em">${parameter}</p>

<p style="margin-left:6%; margin-top: 1em">The value, if
any, of parameter is substituted.</p>

<p style="margin-left:6%; margin-top: 1em">The parameter
name or symbol can be enclosed in braces, which are optional
except for positional parameters with more than one digit or
when parameter is followed by a character that could be
interpreted as part of the name. If a parameter expansion
occurs inside double-quotes:</p>

<p style="margin-top: 1em">1.</p>

<p style="margin-left:13%;">Pathname expansion is not
performed on the results of the expansion.</p>

<p style="margin-top: 1em">2.</p>

<p style="margin-left:13%;">Field splitting is not
performed on the results of the expansion, with the
exception of @.</p>

<p style="margin-left:6%; margin-top: 1em">In addition, a
parameter expansion can be modified by using one of the
following formats.</p>

<p style="margin-top: 1em">${parameter:-word}</p>

<p style="margin-left:35%; margin-top: 1em">Use Default
Values. If parameter is unset or null, the expansion of word
is substituted; otherwise, the value of parameter is
substituted.</p>

<p style="margin-top: 1em">${parameter:=word}</p>

<p style="margin-left:35%; margin-top: 1em">Assign Default
Values. If parameter is unset or null, the expansion of word
is assigned to parameter. In all cases, the final value of
parameter is substituted. Only variables, not positional
parameters or special parameters, can be assigned in this
way.</p>

<p style="margin-top: 1em">${parameter:?[word]}</p>

<p style="margin-left:35%; margin-top: 1em">Indicate Error
if Null or Unset. If parameter is unset or null, the
expansion of word (or a message indicating it is unset if
word is omitted) is written to standard error and the shell
exits with a nonzero exit status. Otherwise, the value of
parameter is substituted. An interactive shell need not
exit.</p>

<p style="margin-top: 1em">${parameter:+word}</p>

<p style="margin-left:35%; margin-top: 1em">Use Alternative
Value. If parameter is unset or null, null is substituted;
otherwise, the expansion of word is substituted.</p>

<p style="margin-left:6%; margin-top: 1em">In the parameter
expansions shown previously, use of the colon in the format
results in a test for a parameter that is unset or null;
omission of the colon results in a test for a parameter that
is only unset.</p>

<p style="margin-top: 1em">${#parameter}</p>

<p style="margin-left:35%; margin-top: 1em">String Length.
The length in characters of the value of parameter.</p>

<p style="margin-left:6%; margin-top: 1em">The following
four varieties of parameter expansion provide for substring
processing. In each case, pattern matching notation (see
<i>Shell Patterns</i>), rather than regular expression
notation, is used to evaluate the patterns. If parameter is
* or @, the result of the expansion is unspecified.
Enclosing the full parameter expansion string in
double-quotes does not cause the following four varieties of
pattern characters to be quoted, whereas quoting characters
within the braces has this effect.</p>

<p style="margin-top: 1em">${parameter%word}</p>

<p style="margin-left:35%; margin-top: 1em">Remove Smallest
Suffix Pattern. The word is expanded to produce a pattern.
The parameter expansion then results in parameter, with the
smallest portion of the suffix matched by the pattern
deleted.</p>

<p style="margin-top: 1em">${parameter%%word}</p>

<p style="margin-left:35%; margin-top: 1em">Remove Largest
Suffix Pattern. The word is expanded to produce a pattern.
The parameter expansion then results in parameter, with the
largest portion of the suffix matched by the pattern
deleted.</p>

<p style="margin-top: 1em">${parameter#word}</p>

<p style="margin-left:35%; margin-top: 1em">Remove Smallest
Prefix Pattern. The word is expanded to produce a pattern.
The parameter expansion then results in parameter, with the
smallest portion of the prefix matched by the pattern
deleted.</p>

<p style="margin-top: 1em">${parameter##word}</p>

<p style="margin-left:35%; margin-top: 1em">Remove Largest
Prefix Pattern. The word is expanded to produce a pattern.
The parameter expansion then results in parameter, with the
largest portion of the prefix matched by the pattern
deleted.</p>

<p style="margin-left:6%; margin-top: 1em"><b>Command
Substitution</b> <br>
Command substitution allows the output of a command to be
substituted in place of the command name itself. Command
substitution occurs when the command is enclosed as
follows:</p>

<p style="margin-left:14%; margin-top: 1em">$(command)</p>

<p style="margin-left:6%; margin-top: 1em">or (</p>

<p>&ldquo;backquoted&rdquo; version ):</p>


<p style="margin-left:14%; margin-top: 1em">&rsquo;command&rsquo;</p>

<p style="margin-left:6%; margin-top: 1em">The shell
expands the command substitution by executing command in a
subshell environment and replacing the command substitution
with the standard output of the command, removing sequences
of one or more &lang;</p>

<p>newline &rang; s at the end of the substitution.
(Embedded &lang; <br>
newline &rang; s before the end of the output are not
removed; however, during field splitting, they may be
translated into &lang; <br>
space &rang; s, depending on the value of IFS and quoting
that is in effect.)</p>

<p style="margin-left:6%; margin-top: 1em"><b>Arithmetic
Expansion</b> <br>
Arithmetic expansion provides a mechanism for evaluating an
arithmetic expression and substituting its value. The format
for arithmetic expansion is as follows:</p>


<p style="margin-left:14%; margin-top: 1em">$((expression))</p>

<p style="margin-left:6%; margin-top: 1em">The expression
is treated as if it were in double-quotes, except that a
double-quote inside the expression is not treated specially.
The shell expands all tokens in the expression for parameter
expansion, command substitution, and quote removal.</p>

<p style="margin-left:6%; margin-top: 1em">Next, the shell
treats this as an arithmetic expression and substitutes the
value of the expression.</p>

<p style="margin-left:6%; margin-top: 1em"><b>White Space
Splitting (Field Splitting)</b> <br>
After parameter expansion, command substitution, and
arithmetic expansion the shell scans the results of
expansions and substitutions that did not occur in
double-quotes for field splitting and multiple fields can
result.</p>

<p style="margin-left:6%; margin-top: 1em">The shell treats
each character of the IFS as a delimiter and uses the
delimiters to split the results of parameter expansion and
command substitution into fields.</p>

<p style="margin-left:6%; margin-top: 1em"><b>Pathname
Expansion (File Name Generation)</b> <br>
Unless the <b>-f</b> flag is set, file name generation is
performed after word splitting is complete. Each word is
viewed as a series of patterns, separated by slashes. The
process of expansion replaces the word with the names of all
existing files whose names can be formed by replacing each
pattern with a string that matches the specified pattern.
There are two restrictions on this: first, a pattern cannot
match a string containing a slash, and second, a pattern
cannot match a string starting with a period unless the
first character of the pattern is a period. The next section
describes the patterns used for both Pathname Expansion and
the <b>case</b> command.</p>

<p style="margin-left:6%; margin-top: 1em"><b>Shell
Patterns</b> <br>
A pattern consists of normal characters, which match
themselves, and meta-characters. The meta-characters are
&ldquo;!&rdquo;, &ldquo;*&rdquo;, &ldquo;?&rdquo;, and
&ldquo;[&rdquo;. These characters lose their special
meanings if they are quoted. When command or variable
substitution is performed and the dollar sign or back quotes
are not double quoted, the value of the variable or the
output of the command is scanned for these characters and
they are turned into meta-characters.</p>

<p style="margin-left:6%; margin-top: 1em">An asterisk
(&ldquo;*&rdquo;) matches any string of characters. A
question mark matches any single character. A left bracket
(&ldquo;[&rdquo;) introduces a character class. The end of
the character class is indicated by a (&ldquo;]&rdquo;); if
the &ldquo;]&rdquo; is missing then the &ldquo;[&rdquo;
matches a &ldquo;[&rdquo; rather than introducing a
character class. A character class matches any of the
characters between the square brackets. A range of
characters may be specified using a minus sign. The
character class may be complemented by making an exclamation
point the first character of the character class.</p>

<p style="margin-left:6%; margin-top: 1em">To include a
&ldquo;]&rdquo; in a character class, make it the first
character listed (after the &ldquo;!&rdquo;, if any). To
include a minus sign, make it the first or last character
listed.</p>

<p style="margin-left:6%; margin-top: 1em"><b>Builtins</b>
<br>
This section lists the builtin commands which are builtin
because they need to perform some operation that can&rsquo;t
be performed by a separate process. In addition to these,
there are several other commands that may be builtin for
efficiency (e.g. printf(1), echo(1), test(1), etc).</p>

<p style="margin-top: 1em">: <br>
true</p>

<p style="margin-left:15%; margin-top: 1em">A null command
that returns a 0 (true) exit value.</p>

<p style="margin-top: 1em">false</p>

<p style="margin-left:15%; margin-top: 1em">A null command
that returns a 1 (false) exit value.</p>

<p style="margin-top: 1em">. file</p>

<p style="margin-left:15%;">The commands in the specified
file are read and executed by the shell.</p>

<p style="margin-top: 1em">alias [<i>name</i>[<i>=string
...</i>]]</p>

<p style="margin-left:15%;">If <i>name=string</i> is
specified, the shell defines the alias <i>name</i> with
value <i>string</i>. If just <i>name</i> is specified, the
value of the alias <i>name</i> is printed. With no
arguments, the <b>alias</b> builtin prints the names and
values of all defined aliases (see <b>unalias</b>).</p>

<p style="margin-top: 1em">bg [<i>job</i>] <i>...</i></p>

<p style="margin-left:15%;">Continue the specified jobs (or
the current job if no jobs are given) in the background.</p>

<p style="margin-top: 1em">command [<b>-p</b>] [<b>-v</b>]
[<b>-V</b>] <i>command</i> [<i>arg ...</i>]</p>

<p style="margin-left:15%;">Execute the specified command
but ignore shell functions when searching for it. (This is
useful when you have a shell function with the same name as
a builtin command.)</p>

<p style="margin-top: 1em"><b>-p</b></p>

<p style="margin-left:24%; margin-top: 1em">search for
command using a PATH that guarantees to find all the
standard utilities.</p>

<p style="margin-top: 1em"><b>-V</b></p>

<p style="margin-left:24%; margin-top: 1em">Do not execute
the command but search for the command and print the
resolution of the command search. This is the same as the
type builtin.</p>

<p style="margin-top: 1em"><b>-v</b></p>

<p style="margin-left:24%; margin-top: 1em">Do not execute
the command but search for the command and print the
absolute pathname of utilities, the name for builtins or the
expansion of aliases.</p>

<p style="margin-top: 1em">cd|chdir <i>-</i></p>

<p style="margin-top: 1em">cd|chdir [<b>-LP</b>]
[<i>directory</i>]</p>

<p style="margin-left:15%;">Switch to the specified
directory (default HOME). If an entry for CDPATH appears in
the environment of the <b>cd</b> command or the shell
variable CDPATH is set and the directory name does not begin
with a slash, then the directories listed in CDPATH will be
searched for the specified directory. The format of CDPATH
is the same as that of PATH. If a single dash is specified
as the argument, it will be replaced by the value of OLDPWD.
The <b>cd</b> command will print out the name of the
directory that it actually switched to if this is different
from the name that the user gave. These may be different
either because the CDPATH mechanism was used or because the
argument is a single dash. The <b>-P</b> option causes the
physical directory structure to be used, that is, all
symbolic links are resolved to their respective values. The
<b>-L</b> option turns off the effect of any preceding
<b>-P</b> options.</p>

<p style="margin-top: 1em">echo [<b>-n</b>]
<i>args...</i></p>

<p style="margin-left:15%;">Print the arguments on the
standard output, separated by spaces. Unless the <b>-n</b>
option is present, a newline is output following the
arguments.</p>

<p style="margin-left:15%; margin-top: 1em">If any of the
following sequences of characters is encountered during
output, the sequence is not output. Instead, the specified
action is performed:</p>

<p style="margin-top: 1em">\b</p>

<p style="margin-left:26%; margin-top: 1em">A backspace
character is output.</p>

<p style="margin-top: 1em">\c</p>

<p style="margin-left:26%; margin-top: 1em">Subsequent
output is suppressed. This is normally used at the end of
the last argument to suppress the trailing newline that
<b>echo</b> would otherwise output.</p>

<p style="margin-top: 1em">\e</p>

<p style="margin-left:26%; margin-top: 1em">Outputs an
escape character (ESC).</p>

<p style="margin-top: 1em">\f</p>

<p style="margin-left:26%; margin-top: 1em">Output a form
feed.</p>

<p style="margin-top: 1em">\n</p>

<p style="margin-left:26%; margin-top: 1em">Output a
newline character.</p>

<p style="margin-top: 1em">\r</p>

<p style="margin-left:26%; margin-top: 1em">Output a
carriage return.</p>

<p style="margin-top: 1em">\t</p>

<p style="margin-left:26%; margin-top: 1em">Output a
(horizontal) tab character.</p>

<p style="margin-top: 1em">\v</p>

<p style="margin-left:26%; margin-top: 1em">Output a
vertical tab.</p>

<p style="margin-top: 1em">\0<i>digits</i></p>

<p style="margin-left:26%;">Output the character whose
value is given by zero to three octal digits. If there are
zero digits, a nul character is output.</p>

<p style="margin-top: 1em">\\</p>

<p style="margin-left:26%; margin-top: 1em">Output a
backslash.</p>

<p style="margin-left:15%; margin-top: 1em">All other
backslash sequences elicit undefined behaviour.</p>

<p style="margin-top: 1em">eval <i>string ...</i></p>

<p style="margin-left:15%;">Concatenate all the arguments
with spaces. Then re-parse and execute the command.</p>

<p style="margin-top: 1em">exec [<i>command arg
...</i>]</p>

<p style="margin-left:15%;">Unless command is omitted, the
shell process is replaced with the specified program (which
must be a real program, not a shell builtin or function).
Any redirections on the <b>exec</b> command are marked as
permanent, so that they are not undone when the <b>exec</b>
command finishes.</p>

<p style="margin-top: 1em">exit [<i>exitstatus</i>]</p>

<p style="margin-left:15%;">Terminate the shell process. If
<i>exitstatus</i> is given it is used as the exit status of
the shell; otherwise the exit status of the preceding
command is used.</p>

<p style="margin-top: 1em">export <i>name ...</i></p>

<p style="margin-top: 1em">export <b>-p</b></p>

<p style="margin-left:15%;">The specified names are
exported so that they will appear in the environment of
subsequent commands. The only way to un-export a variable is
to unset it. The shell allows the value of a variable to be
set at the same time it is exported by writing</p>

<p style="margin-left:23%; margin-top: 1em">export
name=value</p>

<p style="margin-left:15%; margin-top: 1em">With no
arguments the export command lists the names of all exported
variables. With the <b>-p</b> option specified the output
will be formatted suitably for non-interactive use.</p>

<p style="margin-top: 1em">fc [<b>-e</b> <i>editor</i>]
[<i>first</i> [<i>last</i>]]</p>

<p style="margin-top: 1em">fc <b>-l</b> [<b>-nr</b>]
[<i>first</i> [<i>last</i>]]</p>

<p style="margin-top: 1em">fc <b>-s</b> [<i>old=new</i>]
[<i>first</i>]</p>

<p style="margin-left:15%;">The <b>fc</b> builtin lists, or
edits and re-executes, commands previously entered to an
interactive shell.</p>

<p style="margin-top: 1em"><b>-e</b> editor</p>

<p style="margin-left:24%;">Use the editor named by editor
to edit the commands. The editor string is a command name,
subject to search via the PATH variable. The value in the
FCEDIT variable is used as a default when <b>-e</b> is not
specified. If FCEDIT is null or unset, the value of the
EDITOR variable is used. If EDITOR is null or unset, ed(1)
is used as the editor.</p>

<p style="margin-top: 1em"><b>-l</b> (ell)</p>

<p style="margin-left:24%;">List the commands rather than
invoking an editor on them. The commands are written in the
sequence indicated by the first and last operands, as
affected by <b>-r</b>, with each command preceded by the
command number.</p>

<p style="margin-top: 1em"><b>-n</b></p>

<p style="margin-left:24%; margin-top: 1em">Suppress
command numbers when listing with -l.</p>

<p style="margin-top: 1em"><b>-r</b></p>

<p style="margin-left:24%; margin-top: 1em">Reverse the
order of the commands listed (with <b>-l</b>) or edited
(with neither <b>-l</b> nor <b>-s</b>).</p>

<p style="margin-top: 1em"><b>-s</b></p>

<p style="margin-left:24%; margin-top: 1em">Re-execute the
command without invoking an editor.</p>

<p style="margin-top: 1em">first <br>
last</p>

<p style="margin-left:24%; margin-top: 1em">Select the
commands to list or edit. The number of previous commands
that can be accessed are determined by the value of the
HISTSIZE variable. The value of first or last or both are
one of the following:</p>

<p style="margin-top: 1em">[+]number</p>

<p style="margin-left:33%;">A positive number representing
a command number; command numbers can be displayed with the
<b>-l</b> option.</p>

<p style="margin-top: 1em"><b>-number</b></p>

<p style="margin-left:33%;">A negative decimal number
representing the command that was executed number of
commands previously. For example, -1 is the immediately
previous command.</p>

<p style="margin-top: 1em">string</p>

<p style="margin-left:24%;">A string indicating the most
recently entered command that begins with that string. If
the old=new operand is not also specified with <b>-s</b>,
the string form of the first operand cannot contain an
embedded equal sign.</p>

<p style="margin-left:15%; margin-top: 1em">The following
environment variables affect the execution of fc:</p>

<p style="margin-top: 1em">FCEDIT</p>

<p style="margin-left:28%; margin-top: 1em">Name of the
editor to use.</p>

<p style="margin-top: 1em">HISTSIZE</p>

<p style="margin-left:28%; margin-top: 1em">The number of
previous commands that are accessible.</p>

<p style="margin-top: 1em">fg [<i>job</i>]</p>

<p style="margin-left:15%;">Move the specified job or the
current job to the foreground.</p>

<p style="margin-top: 1em">getopts <i>optstring var</i>
[<i>arg ...</i>]</p>

<p style="margin-left:15%;">The POSIX <b>getopts</b>
command, not to be confused with the <i>Bell
Labs</i>-derived getopt(1).</p>

<p style="margin-left:15%; margin-top: 1em">The first
argument should be a series of letters, each of which may be
optionally followed by a colon to indicate that the option
requires an argument. The variable specified is set to the
parsed option.</p>

<p style="margin-left:15%; margin-top: 1em">The
<b>getopts</b> command deprecates the older getopt(1)
utility due to its handling of arguments containing
whitespace.</p>

<p style="margin-left:15%; margin-top: 1em">The
<b>getopts</b> builtin may be used to obtain options and
their arguments from a list of parameters. When invoked,
<b>getopts</b> places the value of the next option from the
option string in the list in the shell variable specified by
<i>var</i> and its index in the shell variable OPTIND. When
the shell is invoked, OPTIND is initialized to 1. For each
option that requires an argument, the <b>getopts</b> builtin
will place it in the shell variable OPTARG. If an option is
not allowed for in the <i>optstring</i>, then OPTARG will be
unset.</p>

<p style="margin-left:15%; margin-top: 1em">By default, the
variables <i>$1</i>, <i>...</i>, <i>$n</i> are inspected; if
<i>arg</i>s are specified, they&rsquo;ll be parsed
instead.</p>


<p style="margin-left:15%; margin-top: 1em"><i>optstring</i>
is a string of recognized option letters (see getopt(3)). If
a letter is followed by a colon, the option is expected to
have an argument which may or may not be separated from it
by white space. If an option character is not found where
expected, <b>getopts</b> will set the variable <i>var</i> to
a &ldquo;?&rdquo;; <b>getopts</b> will then unset OPTARG and
write output to standard error. By specifying a colon as the
first character of <i>optstring</i> all errors will be
ignored.</p>

<p style="margin-left:15%; margin-top: 1em">After the last
option <b>getopts</b> will return a non-zero value and set
<i>var</i> to &ldquo;?&rdquo;.</p>

<p style="margin-left:15%; margin-top: 1em">The following
code fragment shows how one might process the arguments for
a command that can take the options [a] and [b], and the
option [c], which requires an argument.</p>

<p style="margin-left:23%; margin-top: 1em">while getopts
abc: f <br>
do</p>

<table width="100%" border="0" rules="none" frame="void"
       cellspacing="0" cellpadding="0">
<tr valign="top" align="left">
<td width="33%"></td>
<td width="11%">


<p>case $f in</p></td>
<td width="10%"></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="33%"></td>
<td width="11%">


<p>a | b)</p></td>
<td width="10%">


<p>flag=$f;;</p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="33%"></td>
<td width="11%">


<p>c)</p></td>
<td width="10%">


<p>carg=$OPTARG;;</p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="33%"></td>
<td width="11%">


<p>\?)</p></td>
<td width="10%">


<p>echo $USAGE; exit 1;;</p></td>
<td width="46%">
</td></tr>
<tr valign="top" align="left">
<td width="33%"></td>
<td width="11%">


<p>esac</p></td>
<td width="10%"></td>
<td width="46%">
</td></tr>
</table>

<p style="margin-left:23%;">done <br>
shift $((OPTIND - 1))</p>

<p style="margin-left:15%; margin-top: 1em">This code will
accept any of the following as equivalent:</p>

<p style="margin-left:23%; margin-top: 1em">cmd -acarg file
file <br>
cmd -a -c arg file file <br>
cmd -carg -a file file <br>
cmd -a -carg -- file file</p>

<p style="margin-top: 1em">hash [<i>command ...</i>]</p>

<p style="margin-top: 1em">hash <b>-r</b></p>

<p style="margin-left:15%;">The shell maintains a hash
table which remembers the locations of commands. With no
arguments whatsoever, the <b>hash</b> command prints out the
contents of this table. Entries which have not been looked
at since the last <b>cd</b> command are marked with an
asterisk; it is possible for these entries to be
invalid.</p>

<p style="margin-left:15%; margin-top: 1em">With arguments,
the <b>hash</b> command removes the specified commands from
the hash table (unless they are functions) and then locates
them. The <b>-r</b> option causes the hash command to delete
all the entries in the hash table except for functions.</p>

<p style="margin-top: 1em">jobs [ <b><br>
-lp</b>] [<i>job ...</i>]</p>

<p style="margin-left:15%;">Display the status of all, or
just the specified, <i>job</i>s:</p>

<p>By default</p>

<p style="margin-left:37%; margin-top: 1em">display the job
number, currency (<b>+-</b>) status, if any, the job state,
and its shell command.</p>

<p><b>-l</b></p>

<p style="margin-left:37%; margin-top: 1em">also output the
PID of the group leader, and just the PID and shell commands
of other members of the job.</p>

<p><b>-p</b></p>

<p style="margin-left:37%; margin-top: 1em">Display only
leader PIDs, one per line.</p>

<p style="margin-top: 1em">kill [ <b><br>
-s</b> <i>sigspec</i> | <b>-</b><i>signum</i> |
<b>-</b><i>sigspec</i>] [<i>pid</i> | <i>job ...</i>]</p>

<p style="margin-left:15%;">Equivalent to kill(1), but a
<i>job</i> spec may also be specified. Signals can be either
case-insensitive names without SIG prefixes or decimal
numbers; the default is TERM.</p>

<p style="margin-top: 1em">kill <b>-l</b> [<i>signum</i> |
<i>exitstatus</i>]</p>

<p style="margin-left:15%;">List available signal names
without the SIG prefix (<i>sigspec</i>s). If <i>signum</i>
specified, display just the <i>sigspec</i> for that signal.
If <i>exitstatus</i> specified (&gt; <b>128</b>), display
just the <i>sigspec</i> that caused it.</p>

<p style="margin-top: 1em">pwd [<b>-LP</b>]</p>

<p style="margin-left:15%;">builtin command remembers what
the current directory is rather than recomputing it each
time. This makes it faster. However, if the current
directory is renamed, the builtin version of <b>pwd</b> will
continue to print the old name for the directory. The
<b>-P</b> option causes the physical value of the current
working directory to be shown, that is, all symbolic links
are resolved to their respective values. The <b>-L</b>
option turns off the effect of any preceding <b>-P</b>
options.</p>

<p style="margin-top: 1em">read [<b>-p</b> <i>prompt</i>]
[<b>-r</b>] <i>variable</i> [<i>...</i>]</p>

<p style="margin-left:15%;">The prompt is printed if the
<b>-p</b> option is specified and the standard input is a
terminal. Then a line is read from the standard input. The
trailing newline is deleted from the line and the line is
split as described in the section on word splitting above,
and the pieces are assigned to the variables in order. At
least one variable must be specified. If there are more
pieces than variables, the remaining pieces (along with the
characters in IFS that separated them) are assigned to the
last variable. If there are more variables than pieces, the
remaining variables are assigned the null string. The
<b>read</b> builtin will indicate success unless EOF is
encountered on input, in which case failure is returned.</p>

<p style="margin-left:15%; margin-top: 1em">By default,
unless the <b>-r</b> option is specified, the backslash
&ldquo;\&rdquo; acts as an escape character, causing the
following character to be treated literally. If a backslash
is followed by a newline, the backslash and the newline will
be deleted.</p>

<p style="margin-top: 1em">readonly <i>name ...</i></p>

<p style="margin-top: 1em">readonly <b>-p</b></p>

<p style="margin-left:15%;">The specified names are marked
as read only, so that they cannot be subsequently modified
or unset. The shell allows the value of a variable to be set
at the same time it is marked read only by writing</p>

<p style="margin-left:23%; margin-top: 1em">readonly
name=value</p>

<p style="margin-left:15%; margin-top: 1em">With no
arguments the readonly command lists the names of all read
only variables. With the <b>-p</b> option specified the
output will be formatted suitably for non-interactive
use.</p>

<p style="margin-top: 1em">printf <i>format</i> [ <i><br>
value</i>]...</p>

<p style="margin-left:15%;"><b>printf</b> formats and
prints its arguments according to <i>format</i>, a character
string which contains three types of objects: plain
characters, which are simply copied to standard output,
character escape sequences which are converted and copied to
the standard output, and format specifications, each of
which causes printing of the next successive
<i>value</i>.</p>

<p style="margin-left:15%; margin-top: 1em">Each
<i>value</i> is treated as a string if the corresponding
format specification is either <b>b</b>, <b>c</b>, or
<b>s</b>; otherwise it is evaluated as a C constant, with
the following additions:</p>

<p><b>&bull;</b></p>

<p style="margin-left:28%;">A leading plus or minus sign is
allowed.</p>

<p><b>&bull;</b></p>

<p style="margin-left:28%;">If the leading character is a
single or double quote, the value of the next byte.</p>

<p style="margin-left:15%; margin-top: 1em">The format
string is reused as often as necessary until all
<i>value</i>s are consumed. Any extra format specifications
are evaluated with zero or the null string.</p>

<p style="margin-left:15%; margin-top: 1em">Character
escape sequences are in backslash notation as defined in
ANSI X3.159-1989 (&ldquo;ANSI&nbsp;C89&rdquo;). The
characters and their meanings are as follows:</p>

<p style="margin-top: 1em"><b>\a</b></p>

<p style="margin-left:33%; margin-top: 1em">Write a
&lt;bell&gt; character.</p>

<p style="margin-top: 1em"><b>\b</b></p>

<p style="margin-left:33%; margin-top: 1em">Write a
&lt;backspace&gt; character.</p>

<p style="margin-top: 1em"><b>\e</b></p>

<p style="margin-left:33%; margin-top: 1em">Write an
&lt;escape&gt; (ESC) character.</p>

<p style="margin-top: 1em"><b>\f</b></p>

<p style="margin-left:33%; margin-top: 1em">Write a
&lt;form-feed&gt; character.</p>

<p style="margin-top: 1em"><b>\n</b></p>

<p style="margin-left:33%; margin-top: 1em">Write a
&lt;new-line&gt; character.</p>

<p style="margin-top: 1em"><b>\r</b></p>

<p style="margin-left:33%; margin-top: 1em">Write a
&lt;carriage return&gt; character.</p>

<p style="margin-top: 1em"><b>\t</b></p>

<p style="margin-left:33%; margin-top: 1em">Write a
&lt;tab&gt; character.</p>

<p style="margin-top: 1em"><b>\v</b></p>

<p style="margin-left:33%; margin-top: 1em">Write a
&lt;vertical tab&gt; character.</p>

<p style="margin-top: 1em"><b>\\</b></p>

<p style="margin-left:33%; margin-top: 1em">Write a
backslash character.</p>

<p style="margin-top: 1em"><b>\</b><i>num</i></p>

<p style="margin-left:33%; margin-top: 1em">Write an 8-bit
character whose ASCII value is the 1-, 2-, or 3-digit octal
number <i>num</i>.</p>

<p style="margin-left:15%; margin-top: 1em">Each format
specification is introduced by the percent character
(&rsquo;&rsquo;%&rsquo;&rsquo;). The remainder of the format
specification includes, in the following order:</p>

<p style="margin-top: 1em">Zero or more of the following
flags:</p>

<p style="margin-top: 1em"><b>#</b></p>

<p style="margin-left:36%; margin-top: 1em">A
&rsquo;#&rsquo; character specifying that the value should
be printed in an &rsquo;&rsquo;alternative
form&rsquo;&rsquo;. For <b>b</b>, <b>c</b>, <b>d</b>, and
<b>s</b> formats, this option has no effect. For the
<b>o</b> format the precision of the number is increased to
force the first character of the output string to a zero.
For the <b>x</b> (<b>X</b>) format, a non-zero result has
the string 0x (0X) prepended to it. For <b>e</b>, <b>E</b>,
<b>f</b>, <b>g</b>, and <b>G</b> formats, the result will
always contain a decimal point, even if no digits follow the
point (normally, a decimal point only appears in the results
of those formats if a digit follows the decimal point). For
<b>g</b> and <b>G</b> formats, trailing zeros are not
removed from the result as they would otherwise be.</p>

<p style="margin-top: 1em"><b>-</b></p>

<p style="margin-left:36%; margin-top: 1em">A minus sign
&rsquo;-&rsquo; which specifies <i>left adjustment</i> of
the output in the indicated field;</p>

<p style="margin-top: 1em"><b>+</b></p>

<p style="margin-left:36%; margin-top: 1em">A
&rsquo;+&rsquo; character specifying that there should
always be a sign placed before the number when using signed
formats.</p>

<p style="margin-top: 1em">&rsquo;&nbsp;&rsquo;</p>

<p style="margin-left:36%; margin-top: 1em">A space
specifying that a blank should be left before a positive
number for a signed format. A &rsquo;+&rsquo; overrides a
space if both are used;</p>

<p style="margin-top: 1em"><b>0</b></p>

<p style="margin-left:36%; margin-top: 1em">A zero
&rsquo;0&rsquo; character indicating that zero-padding
should be used rather than blank-padding. A &rsquo;-&rsquo;
overrides a &rsquo;0&rsquo; if both are used;</p>

<p style="margin-top: 1em">Field Width:</p>

<p style="margin-left:26%;">An optional digit string
specifying a <i>field width</i>; if the output string has
fewer characters than the field width it will be
blank-padded on the left (or right, if the left-adjustment
indicator has been given) to make up the field width (note
that a leading zero is a flag, but an embedded zero is part
of a field width);</p>

<p style="margin-top: 1em">Precision:</p>

<p style="margin-left:26%;">An optional period,
&rsquo;<b>.</b>&rsquo;, followed by an optional digit string
giving a <i>precision</i> which specifies the number of
digits to appear after the decimal point, for <b>e</b> and
<b>f</b> formats, or the maximum number of bytes to be
printed from a string (<b>b</b> and <b>s</b> formats); if
the digit string is missing, the precision is treated as
zero;</p>

<p style="margin-top: 1em">Format:</p>

<p style="margin-left:26%;">A character which indicates the
type of format to use (one of <b>diouxXfwEgGbcs</b>).</p>

<p style="margin-left:15%; margin-top: 1em">A field width
or precision may be &rsquo;<b>*</b>&rsquo; instead of a
digit string. In this case an <i>argument</i> supplies the
field width or precision.</p>

<p style="margin-left:15%; margin-top: 1em">The format
characters and their meanings are:</p>

<p style="margin-top: 1em"><b>diouXx</b></p>

<p style="margin-left:31%; margin-top: 1em">The
<i>argument</i> is printed as a signed decimal (d or i),
unsigned octal, unsigned decimal, or unsigned hexadecimal (X
or x), respectively.</p>

<p style="margin-top: 1em"><b>f</b></p>

<p style="margin-left:31%; margin-top: 1em">The
<i>argument</i> is printed in the style [-]ddd<b>.</b>ddd
where the number of d&rsquo;s after the decimal point is
equal to the precision specification for the argument. If
the precision is missing, 6 digits are given; if the
precision is explicitly 0, no digits and no decimal point
are printed.</p>

<p style="margin-top: 1em"><b>eE</b></p>

<p style="margin-left:31%; margin-top: 1em">The
<i>argument</i> is printed in the style
[-]d<b>.</b>ddd<b>e</b>&plusmn;dd where there is one digit
before the decimal point and the number after is equal to
the precision specification for the argument; when the
precision is missing, 6 digits are produced. An upper-case E
is used for an &rsquo;E&rsquo; format.</p>

<p style="margin-top: 1em"><b>gG</b></p>

<p style="margin-left:31%; margin-top: 1em">The
<i>argument</i> is printed in style <b>f</b> or in style
<b>e</b> (<b>E</b>) whichever gives full precision in
minimum space.</p>

<p style="margin-top: 1em"><b>b</b></p>

<p style="margin-left:31%; margin-top: 1em">Characters from
the string <i>argument</i> are printed with backslash-escape
sequences expanded. <br>
The following additional backslash-escape sequences are
supported:</p>

<p style="margin-top: 1em"><b>\c</b></p>

<p style="margin-left:41%; margin-top: 1em">Causes
<b>dash</b> to ignore any remaining characters in the string
operand containing it, any remaining string operands, and
any additional characters in the format operand.</p>

<p style="margin-top: 1em"><b>\0</b><i>num</i></p>

<p style="margin-left:41%; margin-top: 1em">Write an 8-bit
character whose ASCII value is the 1-, 2-, or 3-digit octal
number <i>num</i>.</p>

<p style="margin-top: 1em"><b>c</b></p>

<p style="margin-left:31%; margin-top: 1em">The first
character of <i>argument</i> is printed.</p>

<p style="margin-top: 1em"><b>s</b></p>

<p style="margin-left:31%; margin-top: 1em">Characters from
the string <i>argument</i> are printed until the end is
reached or until the number of bytes indicated by the
precision specification is reached; if the precision is
omitted, all characters in the string are printed.</p>

<p style="margin-top: 1em"><b>%</b></p>

<p style="margin-left:31%; margin-top: 1em">Print a
&rsquo;%&rsquo;; no argument is used.</p>

<p style="margin-left:15%; margin-top: 1em">In no case does
a non-existent or small field width cause truncation of a
field; padding takes place only if the specified field width
exceeds the actual width.</p>

<p style="margin-top: 1em">set [ <br>
{ <b>-options</b> | <b>+options</b> | <b>-- }</b>] <i>arg
...</i></p>

<p style="margin-left:15%;">The <b>set</b> command performs
three different functions.</p>

<p style="margin-left:15%; margin-top: 1em">With no
arguments, it lists the values of all shell variables.</p>

<p style="margin-left:15%; margin-top: 1em">If options are
given, it sets the specified option flags, or clears them as
described in the section called <i>Argument List
Processing</i>. As a special case, if the option is -o or +o
and no argument is supplied, the shell prints the settings
of all its options. If the option is -o, the settings are
printed in a human-readable format; if the option is +o, the
settings are printed in a format suitable for reinput to the
shell to affect the same option settings.</p>

<p style="margin-left:15%; margin-top: 1em">The third use
of the set command is to set the values of the shell&rsquo;s
positional parameters to the specified args. To change the
positional parameters without changing any options, use
&ldquo;--&rdquo; as the first argument to set. If no args
are present, the set command will clear all the positional
parameters (equivalent to executing &ldquo;shift
$#&rdquo;.)</p>

<p style="margin-top: 1em">shift [<i>n</i>]</p>

<p style="margin-left:15%;">Shift the positional parameters
n times. A <b>shift</b> sets the value of <i>$1</i> to the
value of <i>$2</i>, the value of <i>$2</i> to the value of
<i>$3</i>, and so on, decreasing the value of <i>$#</i> by
one. If n is greater than the number of positional
parameters, <b>shift</b> will issue an error message, and
exit with return status 2.</p>

<p style="margin-top: 1em">test <i>expression</i></p>

<p style="margin-top: 1em">[ <i>expression</i> <b>]</b></p>

<p style="margin-left:15%;">The <b>test</b> utility
evaluates the expression and, if it evaluates to true,
returns a zero (true) exit status; otherwise it returns 1
(false). If there is no expression, test also returns 1
(false).</p>

<p style="margin-left:15%; margin-top: 1em">All operators
and flags are separate arguments to the <b>test</b>
utility.</p>

<p style="margin-left:15%; margin-top: 1em">The following
primaries are used to construct expression:</p>

<p style="margin-top: 1em"><b>-b</b> <i>file</i></p>

<p style="margin-left:33%; margin-top: 1em">True if
<i>file</i> exists and is a block special file.</p>

<p style="margin-top: 1em"><b>-c</b> <i>file</i></p>

<p style="margin-left:33%; margin-top: 1em">True if
<i>file</i> exists and is a character special file.</p>

<p style="margin-top: 1em"><b>-d</b> <i>file</i></p>

<p style="margin-left:33%; margin-top: 1em">True if
<i>file</i> exists and is a directory.</p>

<p style="margin-top: 1em"><b>-e</b> <i>file</i></p>

<p style="margin-left:33%; margin-top: 1em">True if
<i>file</i> exists (regardless of type).</p>

<p style="margin-top: 1em"><b>-f</b> <i>file</i></p>

<p style="margin-left:33%; margin-top: 1em">True if
<i>file</i> exists and is a regular file.</p>

<p style="margin-top: 1em"><b>-g</b> <i>file</i></p>

<p style="margin-left:33%; margin-top: 1em">True if
<i>file</i> exists and its set group ID flag is set.</p>

<p style="margin-top: 1em"><b>-h</b> <i>file</i></p>

<p style="margin-left:33%; margin-top: 1em">True if
<i>file</i> exists and is a symbolic link.</p>

<p style="margin-top: 1em"><b>-k</b> <i>file</i></p>

<p style="margin-left:33%; margin-top: 1em">True if
<i>file</i> exists and its sticky bit is set.</p>

<p style="margin-top: 1em"><b>-n</b> <i>string</i></p>

<p style="margin-left:33%; margin-top: 1em">True if the
length of <i>string</i> is nonzero.</p>

<p style="margin-top: 1em"><b>-p</b> <i>file</i></p>

<p style="margin-left:33%; margin-top: 1em">True if
<i>file</i> is a named pipe (</p>

<p>FIFO ).</p>

<p style="margin-top: 1em"><b>-r</b> <i>file</i></p>

<p style="margin-left:33%; margin-top: 1em">True if
<i>file</i> exists and is readable.</p>

<p style="margin-top: 1em"><b>-s</b> <i>file</i></p>

<p style="margin-left:33%; margin-top: 1em">True if
<i>file</i> exists and has a size greater than zero.</p>

<p style="margin-top: 1em"><b>-t</b>
<i>file_descriptor</i></p>

<p style="margin-left:33%;">True if the file whose file
descriptor number is <i>file_descriptor</i> is open and is
associated with a terminal.</p>

<p style="margin-top: 1em"><b>-u</b> <i>file</i></p>

<p style="margin-left:33%; margin-top: 1em">True if
<i>file</i> exists and its set user ID flag is set.</p>

<p style="margin-top: 1em"><b>-w</b> <i>file</i></p>

<p style="margin-left:33%; margin-top: 1em">True if
<i>file</i> exists and is writable. True indicates only that
the write flag is on. The file is not writable on a
read-only file system even if this test indicates true.</p>

<p style="margin-top: 1em"><b>-x</b> <i>file</i></p>

<p style="margin-left:33%; margin-top: 1em">True if
<i>file</i> exists and is executable. True indicates only
that the execute flag is on. If <i>file</i> is a directory,
true indicates that <i>file</i> can be searched.</p>

<p style="margin-top: 1em"><b>-z</b> <i>string</i></p>

<p style="margin-left:33%; margin-top: 1em">True if the
length of <i>string</i> is zero.</p>

<p style="margin-top: 1em"><b>-L</b> <i>file</i></p>

<p style="margin-left:33%; margin-top: 1em">True if
<i>file</i> exists and is a symbolic link. This operator is
retained for compatibility with previous versions of this
program. Do not rely on its existence; use <b>-h</b>
instead.</p>

<p style="margin-top: 1em"><b>-O</b> <i>file</i></p>

<p style="margin-left:33%; margin-top: 1em">True if
<i>file</i> exists and its owner matches the effective user
id of this process.</p>

<p style="margin-top: 1em"><b>-G</b> <i>file</i></p>

<p style="margin-left:33%; margin-top: 1em">True if
<i>file</i> exists and its group matches the effective group
id of this process.</p>

<p style="margin-top: 1em"><b>-S</b> <i>file</i></p>

<p style="margin-left:33%; margin-top: 1em">True if
<i>file</i> exists and is a socket.</p>

<p style="margin-top: 1em"><i>file1</i> <b>-nt</b>
<i>file2</i></p>

<p style="margin-left:33%;">True if <i>file1</i> and
<i>file2</i> exist and <i>file1</i> is newer than
<i>file2</i>.</p>

<p style="margin-top: 1em"><i>file1</i> <b>-ot</b>
<i>file2</i></p>

<p style="margin-left:33%;">True if <i>file1</i> and
<i>file2</i> exist and <i>file1</i> is older than
<i>file2</i>.</p>

<p style="margin-top: 1em"><i>file1</i> <b>-ef</b>
<i>file2</i></p>

<p style="margin-left:33%;">True if <i>file1</i> and
<i>file2</i> exist and refer to the same file.</p>

<p style="margin-top: 1em"><i>string</i></p>

<p style="margin-left:33%; margin-top: 1em">True if
<i>string</i> is not the null string.</p>

<p style="margin-top: 1em"><i>s1</i> <b>=</b> <i>s2</i></p>

<p style="margin-left:33%; margin-top: 1em">True if the
strings <i>s1</i> and <i>s2</i> are identical.</p>

<p style="margin-top: 1em"><i>s1</i> <b>!=</b>
<i>s2</i></p>

<p style="margin-left:33%; margin-top: 1em">True if the
strings <i>s1</i> and <i>s2</i> are not identical.</p>

<p style="margin-top: 1em"><i>s1</i> <b>&lt;</b>
<i>s2</i></p>

<p style="margin-left:33%; margin-top: 1em">True if string
<i>s1</i> comes before <i>s2</i> based on the ASCII value of
their characters.</p>

<p style="margin-top: 1em"><i>s1</i> <b>&gt;</b>
<i>s2</i></p>

<p style="margin-left:33%; margin-top: 1em">True if string
<i>s1</i> comes after <i>s2</i> based on the ASCII value of
their characters.</p>

<p style="margin-top: 1em"><i>n1</i> <b>-eq</b>
<i>n2</i></p>

<p style="margin-left:33%; margin-top: 1em">True if the
integers <i>n1</i> and <i>n2</i> are algebraically
equal.</p>

<p style="margin-top: 1em"><i>n1</i> <b>-ne</b>
<i>n2</i></p>

<p style="margin-left:33%; margin-top: 1em">True if the
integers <i>n1</i> and <i>n2</i> are not algebraically
equal.</p>

<p style="margin-top: 1em"><i>n1</i> <b>-gt</b>
<i>n2</i></p>

<p style="margin-left:33%; margin-top: 1em">True if the
integer <i>n1</i> is algebraically greater than the integer
<i>n2</i>.</p>

<p style="margin-top: 1em"><i>n1</i> <b>-ge</b>
<i>n2</i></p>

<p style="margin-left:33%; margin-top: 1em">True if the
integer <i>n1</i> is algebraically greater than or equal to
the integer <i>n2</i>.</p>

<p style="margin-top: 1em"><i>n1</i> <b>-lt</b>
<i>n2</i></p>

<p style="margin-left:33%; margin-top: 1em">True if the
integer <i>n1</i> is algebraically less than the integer
<i>n2</i>.</p>

<p style="margin-top: 1em"><i>n1</i> <b>-le</b>
<i>n2</i></p>

<p style="margin-left:33%; margin-top: 1em">True if the
integer <i>n1</i> is algebraically less than or equal to the
integer <i>n2</i>.</p>

<p style="margin-left:15%; margin-top: 1em">These primaries
can be combined with the following operators:</p>

<p style="margin-top: 1em"><b>!</b> <i>expression</i></p>

<p style="margin-left:33%; margin-top: 1em">True if
<i>expression</i> is false.</p>

<p style="margin-top: 1em"><i>expression1</i> <b>-a</b>
<i>expression2</i></p>

<p style="margin-left:33%;">True if both <i>expression1</i>
and <i>expression2</i> are true.</p>

<p style="margin-top: 1em"><i>expression1</i> <b>-o</b>
<i>expression2</i></p>

<p style="margin-left:33%;">True if either
<i>expression1</i> or <i>expression2</i> are true.</p>


<p style="margin-top: 1em"><b>(</b><i>expression</i><b>)</b></p>

<p style="margin-left:33%; margin-top: 1em">True if
expression is true.</p>

<p style="margin-left:15%; margin-top: 1em">The <b>-a</b>
operator has higher precedence than the <b>-o</b>
operator.</p>

<p style="margin-top: 1em">times</p>

<p style="margin-left:15%; margin-top: 1em">Print the
accumulated user and system times for the shell and for
processes run from the shell. The return status is 0.</p>

<p style="margin-top: 1em">trap [<i>action signal
...</i>]</p>

<p style="margin-left:15%;">Cause the shell to parse and
execute action when any of the specified signals are
received. The signals are specified by signal number or as
the name of the signal. If <i>signal</i> is 0 or EXIT, the
action is executed when the shell exits. <i>action</i> may
be empty (&rsquo;&rsquo;), which causes the specified
signals to be ignored. With <i>action</i> omitted or set to
&rsquo;-&rsquo; the specified signals are set to their
default action. When the shell forks off a subshell, it
resets trapped (but not ignored) signals to the default
action. The <b>trap</b> command has no effect on signals
that were ignored on entry to the shell. <b>trap</b> without
any arguments cause it to write a list of signals and their
associated action to the standard output in a format that is
suitable as an input to the shell that achieves the same
trapping results.</p>

<p style="margin-left:15%; margin-top: 1em">Examples:</p>

<p style="margin-left:23%; margin-top: 1em">trap</p>

<p style="margin-left:15%; margin-top: 1em">List trapped
signals and their corresponding action</p>

<p style="margin-left:23%; margin-top: 1em">trap
&rsquo;&rsquo; INT QUIT tstp 30</p>

<p style="margin-left:15%; margin-top: 1em">Ignore signals
INT QUIT TSTP USR1</p>

<p style="margin-left:23%; margin-top: 1em">trap date
INT</p>

<p style="margin-left:15%; margin-top: 1em">Print date upon
receiving signal INT</p>

<p style="margin-top: 1em">type [<i>name ...</i>]</p>

<p style="margin-left:15%;">Interpret each name as a
command and print the resolution of the command search.
Possible resolutions are: shell keyword, alias, shell
builtin, command, tracked alias and not found. For aliases
the alias expansion is printed; for commands and tracked
aliases the complete pathname of the command is printed.</p>

<p style="margin-top: 1em">ulimit <br>
[<b>-H</b> | <b>-S</b>] [<b>-a</b> | <b>-tfdscmlpnvwr</b>
[<i>value</i>]]</p>

<p style="margin-left:15%;">Inquire about or set the hard
or soft limits on processes or set new limits. The choice
between hard limit (which no process is allowed to violate,
and which may not be raised once it has been lowered) and
soft limit (which causes processes to be signaled but not
necessarily killed, and which may be raised) is made with
these flags:</p>

<p style="margin-top: 1em"><b>-H</b></p>

<p style="margin-left:31%; margin-top: 1em">set or inquire
about hard limits</p>

<p style="margin-top: 1em"><b>-S</b></p>

<p style="margin-left:31%; margin-top: 1em">set or inquire
about soft limits. If neither <b>-H</b> nor <b>-S</b> is
specified, the soft limit is displayed or both limits are
set. If both are specified, the last one wins.</p>

<p style="margin-left:15%; margin-top: 1em">The limit to be
interrogated or set, then, is chosen by specifying any one
of these flags:</p>

<p style="margin-top: 1em"><b>-a</b></p>

<p style="margin-left:31%; margin-top: 1em">show all the
current limits</p>

<p style="margin-top: 1em"><b>-t</b></p>

<p style="margin-left:31%; margin-top: 1em">show or set the
limit on CPU time (in seconds)</p>

<p style="margin-top: 1em"><b>-f</b></p>

<p style="margin-left:31%; margin-top: 1em">show or set the
limit on the largest file that can be created (in 512-byte
blocks)</p>

<p style="margin-top: 1em"><b>-d</b></p>

<p style="margin-left:31%; margin-top: 1em">show or set the
limit on the data segment size of a process (in
kilobytes)</p>

<p style="margin-top: 1em"><b>-s</b></p>

<p style="margin-left:31%; margin-top: 1em">show or set the
limit on the stack size of a process (in kilobytes)</p>

<p style="margin-top: 1em"><b>-c</b></p>

<p style="margin-left:31%; margin-top: 1em">show or set the
limit on the largest core dump size that can be produced (in
512-byte blocks)</p>

<p style="margin-top: 1em"><b>-m</b></p>

<p style="margin-left:31%; margin-top: 1em">show or set the
limit on the total physical memory that can be in use by a
process (in kilobytes)</p>

<p style="margin-top: 1em"><b>-l</b></p>

<p style="margin-left:31%; margin-top: 1em">show or set the
limit on how much memory a process can lock with mlock(2)
(in kilobytes)</p>

<p style="margin-top: 1em"><b>-p</b></p>

<p style="margin-left:31%; margin-top: 1em">show or set the
limit on the number of processes this user can have at one
time</p>

<p style="margin-top: 1em"><b>-n</b></p>

<p style="margin-left:31%; margin-top: 1em">show or set the
limit on the number files a process can have open at
once</p>

<p style="margin-top: 1em"><b>-v</b></p>

<p style="margin-left:31%; margin-top: 1em">show or set the
limit on the total virtual memory that can be in use by a
process (in kilobytes)</p>

<p style="margin-top: 1em"><b>-w</b></p>

<p style="margin-left:31%; margin-top: 1em">show or set the
limit on the total number of locks held by a process</p>

<p style="margin-top: 1em"><b>-r</b></p>

<p style="margin-left:31%; margin-top: 1em">show or set the
limit on the real-time scheduling priority of a process</p>

<p style="margin-left:15%; margin-top: 1em">If none of
these is specified, it is the limit on file size that is
shown or set. If value is specified, the limit is set to
that number; otherwise the current limit is displayed.</p>

<p style="margin-left:15%; margin-top: 1em">Limits of an
arbitrary process can be displayed or set using the
sysctl(8) utility.</p>

<p style="margin-top: 1em">umask [<i>mask</i>]</p>

<p style="margin-left:15%;">Set the value of umask (see
umask(2)) to the specified octal value. If the argument is
omitted, the umask value is printed.</p>

<p style="margin-top: 1em">unalias <br>
[<b>-a</b>] [<i>name</i>]</p>

<p style="margin-left:15%;">If <i>name</i> is specified,
the shell removes that alias. If <b>-a</b> is specified, all
aliases are removed.</p>

<p style="margin-top: 1em">unset <br>
[<b>-fv</b>] <i>name ...</i></p>

<p style="margin-left:15%;">The specified variables and
functions are unset and unexported. If <b>-f</b> or
<b>-v</b> is specified, the corresponding function or
variable is unset, respectively. If a given name corresponds
to both a variable and a function, and no options are given,
only the variable is unset.</p>

<p style="margin-top: 1em">wait [<i>job</i>]</p>

<p style="margin-left:15%;">Wait for the specified job to
complete and return the exit status of the last process in
the job. If the argument is omitted, wait for all jobs to
complete and return an exit status of zero.</p>

<p style="margin-left:6%; margin-top: 1em"><b>Command Line
Editing</b> <br>
When <b>dash</b> is being used interactively from a
terminal, the current command and the command history (see
<b>fc</b> in <i>Builtins</i>) can be edited using vi-mode
command-line editing. This mode uses commands, described
below, similar to a subset of those described in the vi man
page. The command &rsquo;set -o vi&rsquo; enables vi-mode
editing and places sh into vi insert mode. With vi-mode
enabled, sh can be switched between insert mode and command
mode. It is similar to vi: typing &lang; ESC&rang; enters vi
command mode. Hitting &lang; return&rang; while in command
mode will pass the line to the shell.</p>

<p style="margin-top: 1em"><b>EXIT STATUS</b></p>

<p style="margin-left:6%;">Errors that are detected by the
shell, such as a syntax error, will cause the shell to exit
with a non-zero exit status. If the shell is not an
interactive shell, the execution of the shell file will be
aborted. Otherwise the shell will return the exit status of
the last command executed, or if the exit builtin is used
with a numeric argument, it will return the argument.</p>

<p style="margin-top: 1em"><b>ENVIRONMENT</b> <br>
HOME</p>

<p style="margin-left:21%; margin-top: 1em">Set
automatically by login(1) from the user&rsquo;s login
directory in the password file (passwd(4)). This environment
variable also functions as the default argument for the cd
builtin.</p>

<p style="margin-top: 1em">PATH</p>

<p style="margin-left:21%; margin-top: 1em">The default
search path for executables. See the above section <i>Path
Search</i>.</p>

<p style="margin-top: 1em">CDPATH</p>

<p style="margin-left:21%; margin-top: 1em">The search path
used with the cd builtin.</p>

<p style="margin-top: 1em">MAIL</p>

<p style="margin-left:21%; margin-top: 1em">The name of a
mail file, that will be checked for the arrival of new mail.
Overridden by MAILPATH.</p>

<p style="margin-top: 1em">MAILCHECK</p>

<p style="margin-left:21%; margin-top: 1em">The frequency
in seconds that the shell checks for the arrival of mail in
the files specified by the MAILPATH or the MAIL file. If set
to 0, the check will occur at each prompt.</p>

<p style="margin-top: 1em">MAILPATH</p>

<p style="margin-left:21%; margin-top: 1em">A colon
&ldquo;:&rdquo; separated list of file names, for the shell
to check for incoming mail. This environment setting
overrides the MAIL setting. There is a maximum of 10
mailboxes that can be monitored at once.</p>

<p style="margin-top: 1em">PS1</p>

<p style="margin-left:21%; margin-top: 1em">The primary
prompt string, which defaults to &ldquo;$&nbsp;&rdquo;,
unless you are the superuser, in which case it defaults to
&ldquo;#&nbsp;&rdquo;.</p>

<p style="margin-top: 1em">PS2</p>

<p style="margin-left:21%; margin-top: 1em">The secondary
prompt string, which defaults to
&ldquo;&gt;&nbsp;&rdquo;.</p>

<p style="margin-top: 1em">PS4</p>

<p style="margin-left:21%; margin-top: 1em">Output before
each line when execution trace (set -x) is enabled, defaults
to &ldquo;+&nbsp;&rdquo;.</p>

<p style="margin-top: 1em">IFS</p>

<p style="margin-left:21%; margin-top: 1em">Input Field
Separators. This is normally set to &lang; space&rang; ,
&lang; tab&rang; , and &lang; newline&rang; . See the
<i>White Space Splitting</i> section for more details.</p>

<p style="margin-top: 1em">TERM</p>

<p style="margin-left:21%; margin-top: 1em">The default
terminal setting for the shell. This is inherited by
children of the shell, and is used in the history editing
modes.</p>

<p style="margin-top: 1em">HISTSIZE</p>

<p style="margin-left:21%; margin-top: 1em">The number of
lines in the history buffer for the shell.</p>

<p style="margin-top: 1em">PWD</p>

<p style="margin-left:21%; margin-top: 1em">The logical
value of the current working directory. This is set by the
<b>cd</b> command.</p>

<p style="margin-top: 1em">OLDPWD</p>

<p style="margin-left:21%; margin-top: 1em">The previous
logical value of the current working directory. This is set
by the <b>cd</b> command.</p>

<p style="margin-top: 1em">PPID</p>

<p style="margin-left:21%; margin-top: 1em">The process ID
of the parent process of the shell.</p>

<p style="margin-top: 1em"><b>FILES</b></p>

<p style="margin-left:6%;"><i>$HOME/.profile</i></p>


<p style="margin-left:6%; margin-top: 1em"><i>/etc/profile</i></p>

<p style="margin-top: 1em"><b>SEE ALSO</b></p>

<p style="margin-left:6%;">csh(1), echo(1), getopt(1),
ksh(1), login(1), printf(1), test(1), getopt(3), passwd(5),
environ(7), sysctl(8)</p>

<p style="margin-top: 1em"><b>HISTORY</b></p>

<p style="margin-left:6%;"><b>dash</b> is a POSIX-compliant
implementation of /bin/sh that aims to be as small as
possible. <b>dash</b> is a direct descendant of the NetBSD
version of ash (the Almquist SHell), ported to Linux in
early 1997. It was renamed to <b>dash</b> in 2002.</p>

<p style="margin-top: 1em"><b>BUGS</b></p>

<p style="margin-left:6%;">Setuid shell scripts should be
avoided at all costs, as they are a significant security
risk.</p>

<p style="margin-left:6%; margin-top: 1em">PS1, PS2, and
PS4 should be subject to parameter expansion before being
displayed.</p>

<p style="margin-left:6%; margin-top: 1em">BSD
January&nbsp;19, 2003 BSD</p>
<hr>
</body>
</html>
